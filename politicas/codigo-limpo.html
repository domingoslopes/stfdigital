<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
        <meta content="IE=edge" http-equiv="X-UA-Compatible">
        
        <title>STF Digital Developers | Testes</title>
        
        <!-- STYLESHEETS -->
        <link rel="stylesheet" href="assets/styles/fonts.css" type="text/css" >
        <link rel="stylesheet" href="assets/styles/fonts1.css" title="roboto" type="text/css">
        
        <link href="assets/styles/default.css" rel="stylesheet" type="text/css">
    </head>

    <body class="gc-documentation develop guide  dac-nav-open" itemscope="" itemtype="http://schema.org/Article">
        <header id="header-wrapper">
            <div class="dac-header" id="header">
                <div class="dac-header-inner">
                    <a class="dac-nav-toggle" data-dac-toggle-nav="" href="https://developer.android.com/guide/components/fundamentals.html" title="Open navigation"> 
                        <span class="dac-nav-hamburger"> 
                            <span class="dac-nav-hamburger-top"></span> 
                            <span class="dac-nav-hamburger-mid"></span> 
                            <span class="dac-nav-hamburger-bot"></span>
                        </span>
                    </a>
                    <a class="dac-header-logo" href="https://developer.android.com/index.html">
                        <img class="dac-header-logo-image" src="../assets/images/logo.png" srcset="../assets/images/logo.png" width="32" height="32">STF Digital
                    </a>
                    <ul class="dac-header-tabs">
                        <li><a class="dac-header-tab selected" href="#">Desenvolvimento</a></li>
                    </ul>
                    <a class="dac-header-console-btn" href="https://github.com/supremotribunalfederal/stfdigital"> 
                        <img src="../assets/images/github-icon.png" srcset="../assets/images/github-icon.png" />
                        <span class="dac-visible-desktop-inline">Repositório</span>
                    </a>
                </div>
            <!--/.header-wrap.wrap-->
            </div>
        <!--/.header-->
        </header>
    
        <a name="navigation" tabindex="0" class="nav-start-marker">navigation</a>

        <nav class="dac-nav">
            <div class="dac-nav-dimmer" data-dac-toggle-nav=""></div>
            <div class="dac-nav-sidebar" data-swap="" data-dynamic="false" data-transition-speed="300" data-dac-nav="">
                <div data-swap-container="">
                    <a class="dac-nav-back-button dac-swap-section dac-up dac-active" tabindex="0" data-swap-button="" href="../index.html"> 
                        <i class="dac-sprite dac-nav-back"></i> 
                        <span class="dac-nav-back-title">Arquitetura</span>
                    </a>
    
                    <div class="dac-nav-sub dac-swap-section dac-right dac-active">
                        <ul id="nav">
                            <li class="nav-section expanded">
                                <div class="nav-section-header">
                                    <a href="#">Iniciando</a>
                                </div>
                                <ul style="display: block;">
                                    <li><a href="../iniciando/demonstracao.html">Demonstração</a></li>
                                    <li><a href="../iniciando/montagem.html">Monte seu Ambiente</a></li>
                                    <li><a href="../iniciando/comece-agora.html">Comece Agora</a></li>
                                </ul>
                            </li>
                            </br>
                            <li class="nav-section expanded">
                                <div class="nav-section-header">
                                    <a href="#">Arquitetura</a>
                                </div>
                                <ul style="display: block;">
                                    <li><a href="../arquitetura/visao.html">Nossa Visão</a></li>
                                    <li><a href="../arquitetura/estrategia.html">Estratégia Arquitetural</a></li>
                                    <li><a href="../arquitetura/autuacao.html">Estratégia de Implantação</a></li>
                                </ul>
                            </li>
                            </br>
                            <li class="nav-section expanded">
                                <div class="nav-section-header">
                                    <a href="#">Padrões e Políticas</a>
                                </div>
                                <ul style="display: block;">
                                    <li><a href="../politicas/testes.html">Estratégia de Testes</a></li>
                                    <li><a href="../politicas/api.html">Gestão da API</a></li>
                                    <li><a href="../politicas/codigo-limpo.html">Código Limpo</a></li>
                                </ul>
                            </li>
                        </ul>
                    </div>
    
                </div>
            </div>
        </nav>

        <a name="top" tabindex="0"></a>
    
        <div class="wrap clearfix" id="body-content">
            <div class="content-header">
                <ul class="dac-header-crumbs dac-has-content">
                    <li class="dac-header-crumbs-item"><a class="dac-header-crumbs-link" href="#">Desenvolvimento</a></li>
                    <li class="dac-header-crumbs-item"><a class="dac-header-crumbs-link" href="#">Arquitetura</a></li>
                    <li class="dac-header-crumbs-item"><a class="dac-header-crumbs-link" href="#">Estratégia</a></li>
                </ul>
                <h1 itemprop="name">Código Limpo</h1>
            </div>
            <div id="jd-content">
                <div class="jd-descr" itemprop="articleBody">
                    <div id="qv-wrapper">
                        <div id="qv">
                            <h2>Neste documento</h2>
                            <ol>
                                <li>
                                    <a href="#excecoes">Tratamento de Exceções</a>
                                </li>
                                <li>
                                    <a href="#padrao-codificacao">Padrão de Codificação</a>
                                </li>
                            </ol>
                        </div>
                    </div>
    
                    <p>
                        <i>Segundo Robert C. Martin, uma das principais referências na área, "código limpo não é somente 
                        desejável - é necessário. Se o código não estiver limpo, o desenvolvimento decai com o tempo. 
                        Eventualmente, chega a um tal ponto de incerteza, dor e frustração que parece ser mais 
                        fácil começar de novo e reescrever tudo do início. Obviamente que se a reescrita não for 
                        melhor que o original, o problema persiste, e em pouco tempo a equipe acaba onde 
                        tinha começado".</i> 
                    </p>
                        
                    <p>
                        <i>É claro que a definição do que é código limpo depende das preferências pessoais de cada um, mas
                        tentamos descrever aqui um conjunto de recomendações para garantir a qualidade do código e assim
                        facilitar a manutenção, quebrar os ciclos de reescrita e extrair do código o melhor para 
                        os usuários e para os desenvolvedores.</i> 
                    </p>
                        
                    <h2 id="excecoes" style="padding-bottom: 0px;">Tratamento de Exceções</h2>
                    <hr>
    
                    <p>
                        Exceções foram introduzidas na linguagem Java para garantir resiliência e confiabilidade.
                        O objetivo seria assegurar que os sistemas pudessem reagir apropriadamente a situações
                        inesperadas e a contigências específicas. Embora seu propósito seja simples, a forma de utilização 
                        sempre gerou muita confusão. Abaixo, listamos um conjunto de práticas que devem sempre 
                        ser observadas ao lidar com exceções.
                    </p>  
    
                    <h4 id="excecoes" style="padding-bottom: 0px;">Tipos de Exceções</h4>
                    <hr>
    
                    <p>
                        Há grande controvérsia envolvendo o uso de <i>Checked Exceptions</i>, com personalidades
                        como Rod Johnson (criador do Spring Framework) e Gavin King (criador do Hibernate) se
                        posicionando contra seu uso. De fato, Spring, Hibernate e vários outros frameworks
                        estão usando apenas <i>Unchecked Exceptions</i>.
                    </p>

                    <p>
                        <i>Checked Exceptions</i>, implementadas em Java como uma subclasse de <i>Exception</i>
                        foram inicialmente propostas para situações em que o cliente da API pode se recuperar
                        do problema indicado pela exceção. O problema é que essas situações são muito raras.
                        Em geral, seu código não terá a capacidade de se recuperar de uma situação problemática.
                        Quando usada como recomendação padrão, esse tipo de exceção pode levar a problemas
                        de encapsulamento e problemas graves de manutenção. Suponha, por exemplo, que 
                        uma exceção dessas é incluída na API de uma biblioteca de baixo nível. Caso não 
                        seja uma exceção recuperável, essa modificação poderá impactar toda a cadeia
                        de chamadas que termina na chamada dessa API, forçando a inclusão de blocos 
                        "try-catch" ou a inclusão de instruções "throws" em toda a sequência de processamento.
                    </p>
    
                    <p>
                        <i>Unchecked Exceptions</i>, implementadas em Java como uma subclasse de <i>RuntimeException</i>,
                        por outro lado, foram propostas para situações em que o cliente da API não pode se recuperar.
                        Elas podem ser lançadas de qualquer ponto, em qualquer lugar, não exigem declaração e não
                        demandam tratamento. São muito mais convenientes e, por isso, muito mais populares. 
                    </p>
    
                    <p>
                        Recomendamos usar <i>Unchecked Exceptions</i> como escolha padrão e somente naqueles raros casos em
                        que há inquestinável possibilidade de recuperação pelo cliente da API, usar <i>Checked Exceptions</i>.  
                        Portanto, se cliente do método pode tomar alguma ação para se recuperar de um erro esperado, então crie sua
                        exceção como uma <i>Checked Exceptions</i>. Caso contrário, se o cliente não pode fazer nada
                        útil no caso de um erro, então crie sua exceção como uma <i>Unchecked Exceptions</i>.
                    </p>
    
                    <h4 id="hierarquia" style="padding-bottom: 0px;">Hierarquia de Exceções</h4>
                    <hr>

                    <p>
                        Defina sua própria hierarquia de exceções. Ao fazer isso, você poderá utilizar esses tipos
                        para implementação do mecanismo de tratamento de erros que poderá, por exemplo,
                        registrar informações específicas das exceções. Use os tipos de exceções claramente,
                        para definir a causa raiz do problema e eventualmente a severidade do erro (fatal,
                        warn, info, debug).    
                    </p>
                        
                    <h4 id="fluxo" style="padding-bottom: 0px;">Controle de Fluxo</h4>
                    <hr>

                    <p>
                        Exceções não devem ser usadas para controle de fluxo. Não gerencie lógica de negócio com exceções.
                        Use instruções condicionais para isso. Lançar e tratar exceções são operações onerosas.
                        Se o controle pode ser feito com uma instrução condicional, não use exceções porque isso 
                        impacta significativamente a performance geral do sistema, além de reduzir a legibilidade
                        do código. Por exemplo, se um método retorna null, use <a href="https://dzone.com/articles/java-8-optional-replace-your-get-calls">Optionals</a> ou
                        uma instrução <i>if-else</i> em vez de depender do tratamento de exceções para fazer 
                        esse tipo de verificação.
                    </p>

                    <p>
                        Exceções têm um impacto sobre o desempenho global do aplicativo, então devem ser usadas criteriosamente. 
                        Não use exceções se você pode usar uma variável boleana para verificar se uma operação foi 
                        bem-sucedida ou não. Tente sempre retornar uma variável para que o cliente do código 
                        possa controlar o fluxo de execução com base nesse retorno.
                    </p>

                    <p>
                        Identifique e corrija a causa raiz dos problemas para evitar tratamentos desnecessários. 
                        Sempre faça as validações das variáveis que possam assumir valores null antes de executar
                        as operações, verifique o tamanho do array em vez de confiar em ArrayIndexOutOfBoundException.
                    </p>

                    <p>
                        Lance exceçõs para possíveis erros reportados por um método. Por exemplo, se você retorna os
                        valores -1, -2, -3... invés de FileNotFoundException, esse método pode não ser bem
                        entendido.
                    </p>

                    <p>
                        Usar o tratamento de exceções dentro de um loop não é recomendado para muitos casos. 
                        Tente colocar o loop dentro do bloco de tratamento das execeções
                    </p>
                        
                    <h4 id="lancamento" style="padding-bottom: 0px;">Lançamento</h4>
                    <hr>

                    <p>
                        É sempre melhor lançar exceções específicas em vez de lançar exceções mais genéricas, como
                        <i>Throwable</i>, <i>Excpetion</i> or <i>RuntimeException</i>. Ao fazer isso, nós podemos fornecer
                        mais informações sobre o que exatamente ocorreu e o código fica mais legível.
                    </p>

                    <p>                         
                        Sempre que precisar lançar uma exceção, siga o princípio <i>Throw Early or Fail-Fast</i>. A <i>stack trace</i>
                        de uma exceção mostra a sequência exata de chamadas de métodos até o ponto em que ocorreu a exceção,
                        incluindo o nome da classe, o nome do arquivo e o número da linha onde a exceção foi lançada. Por isso,
                        é muito importante lançar a exceção o quanto antes, imediatamente quando a exceção é detectada.
                        Por exemplo, se o erro ocorre em um método mais não é lançada por ele, mas sim pelo método chamado,
                        a <i>stack trace</i> não indicará o posição exata do erro, o que poderá comprometer o tempo de
                        diagnóstica da causa do problema.
                    </p>
                        
                    <h4 id="tratamento" style="padding-bottom: 0px;">Tratamento</h4>
                    <hr>

                    <p>
                        <i>Throwable</i> é a superclasse de todos os erros e exceções em Java. <i>Error</i> é a superclasse
                        de todos os erros capturáveis por qualquer aplicação. Tratar <i>Throwable</i> ou <i>Error</i> significa que
                        erros como OutOfMemoryError, StackOverFlowError e etc. significa que sua aplicação poderia se
                        recuperar de situações como essas, o que obviamente não é possível. Assim, <i>Throwable</i>
                        ou <i>Error</i> não devem ser capturadas porque não há tratamento possível para elas.
                    </p>

                    <p>
                        Sempre faça o tratamento de exceções específicas, nunca de exceções genéricas como <i>Exception</i>. 
                        Não é possível se recuperar de erro que você não conhece, um erro genérico. Só podemos tentar um 
                        outro caminho se conhecemos exatamente qual problema ocorreu. Além de viabilizar
                        o tratamento de um erro específico, isso evita problemas de performance e ainda garante maior 
                        legibilidade do código.
                    </p>

                    <p>
                        Sempre que precisar tratar uma exceção, siga o princípio <i>Catch Late</i>. No caso de <i>checked 
                        exceptions</i>, o compilador Java força que o cliente capture a exceção ou a declare usando a cláusula
                        <i>throws</i>. Assim, geralmente os desenvolvedores tendem a capturar a exceção e não fazer nada
                        além de registrar a <i>stacktrace</i> para evitar erros de compilação. Mas, ao fazer isso
                        você estará escondendo o que realmente aconteceu. É melhor capturar a exceção somente
                        quando ele poderá ser tratada apropriadamente. Use a cláusula <i>throws</i> para declarar
                        a exceção e passar a responsabilidade para o método chamador. Dessa forma, caso nenhum dos 
                        métodos acima conseguir tratar a exceção apropriadamente, ela alcançará o mecanismo de 
                        tratamento global de exceções, cuja responsabilidade é tratar casos como esse.
                    </p>

                    <p>
                        Novamente, não esconda a exceção! Não substitua o tratamento de exceções por um bloco vazio, o registro da 
                        <i>stacktrace</i> ou da exceção, como nas listagens abaixo. Ignorar exceções poderá evitar erros de compilação, 
                        mas vai criar um caos a manutenção posterior.
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">try</span><span class="pln"> {</span> <span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">/* ... */</span></br><span class="str">catch</span><span class="pln"> (Exception e) {</span><span class="pln"><br></span><span class="pln"></span><span class="pln"><br></span><span class="pln">}</span></pre>
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">try</span><span class="pln"> {</span> <span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">/* ... */</span></br><span class="str">catch</span><span class="pln"> (Exception e) {</span><span class="pln"><br></span><span class="pln"></span><span class="pln">&nbsp; &nbsp;LOGGER.info("Erro inesperado");</span><br><span class="pln">}</span></pre>
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">try</span><span class="pln"> {</span> <span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">/* ... */</span></br><span class="str">catch</span><span class="pln"> (Exception e) {</span><span class="pln"><br></span><span class="pln"></span><span class="pln">&nbsp; &nbsp;e.printStackTrace();</span><br><span class="pln">}</span></pre>
                    </p>

                    <p>
                        Não perca a exceção original. Quase todas as exceções fornecem um construtor com um parâmetro para a causa.
                        Ao criar uma exceção customizada, lembre-se de incluir esse construtor.
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">public </span><span class="pln">Exception(String message, Throwable cause)</span> </pre>
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">catch</span><span class="pln"> (IllegalArgumentException exp) {</span></br><span class="pln"></span><span class="str">&nbsp; &nbsp;throw new </span><span class="pln">throw new MyCustomException("Mensagem específica" , exp);</span></br><span class="pln">}</span></pre>
                    </p>

                    <h4 id="logging" style="padding-bottom: 0px;">Logging</h4>
                    <hr>

                    <p>
                        Não log a mesma exceção mais de uma vez, para não haver confusão em relação à localização da exceção.
                        Nós deveríamos sempe logar a mensagem da exceção e essa mensagem dever conter informações precisas
                        para que o chamador possa saber facilmente o que ocorreu. Sempre usa informações detalhadas, 
                        adicionando os valores de varáiveis relevantes quando possível. Por exemplo, se nós estamos
                        escrevendo um código em que uma regra só é aplicada para idosos, 
                        se a idade é menor que 60, então o método dever lançar InvalidAgeException.
                        Nesse caso, se a exceção é lançada sem especificar qual a idade do cidadão, a mensagem pode não ser
                        tão útil quanto no caso em que você informa exatamente que idade causou a exceção.
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">catch</span><span class="pln"> (NoSuchFieldException exp) {</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">LOGGER.error("Exception occurred", exp);</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">throw exp;</span><span class="pln"><br></span><span class="pln">}</span></pre>

                        Logar e lançar uma exceção dentro de um bloco catch é considerado anti-pattern e deveira ser
                        evitado. Logar e lançar a exceção pode resultar em múltiplas mensagens de erro no arquivo de log 
                        para um único problema, dificultando o trabalho dos responsáveis por identificar 
                        e diagnosticar problemas no código.
                    </p>

                    <p>
                        Por fim, lembre-se que granularidade é muito importante. Um bloco de tratamento deve tratar sempre um caso
                        específico. Não coloque centenas de linhas de código dentro de um bloco <i>try-catch</i>. 
                    </p>
                        
                    <h4 id="documentacao" style="padding-bottom: 0px;">Documentação</h4>
                    <hr>

                    <p>
                        Atribuir um código para cada diferente mensagem de exceção é uma boa prática para documentação porque
                        facilita muito a comunicação do tipo de erro. Também recomendamos usar Javadoc @throws para indicar 
                        as exceções lançadas pelos métodos. Isso facilita bastante principalmente no caso de interfaces 
                        que poderá ser usadas em outras aplicações.
                    </p>    

                    <h4 id="nomenclatura" style="padding-bottom: 0px;">Nomenclatura</h4>
                    <hr>

                    <p>
                        O nome das exceções deve ser claro e significativo para comunicar objetivamente qual a causa da exceção.
                        Ao criar suas próprias exceções, siga o padrão já definido pela linguagem. Inicie o nome com a causa
                        e termine com o sufixo <i>Excpetion</i>, como <i>NoSuchMethodExcpetion</i>.
                    </p>    
                        
                    <p>
                        Lembre-se de manter exceções de mesmo tipo dentro da mesma hierarquia. Por exemplo, exceções
                        relacionadas a problemas de IO são todas subclasses de <i>IOExcpetion</i>.
                    </p>    

                    <h2 id="padrao-codificacao" style="padding-bottom: 0px;">Padrão de Codificação</h2>
                    <hr>
    
                    <p>
                        A utilização de um padrão de codificação é importante para reduzir o custo de manutenção do <i>software</i>, já que sua
                        adoção melhora a legibilidade dele. A Sun Microsystems, em seu documento de <i>Convenções de código para a linguagem
                        de programação Java</i>, cita algumas das razões por que convenções de codificação são importantes: 
                        <ul>
                            <li>80% do custo de um <i>software</i> durante seu ciclo de vida é dedicado à manutenção.</li>
                            <li>Dificilmente um <i>software</i> é mantido pelo mesmo desenvolvedor por todo seu ciclo de vida.</li>
                            <li>Padrões de codificação melhoram a legibilidade do código, permitindo que os desenvolvedores
                                entendam novos códigos de forma mais rápida e completa.
                        </ul>
                        Quando convenções de código são projetadas para produzir código de alta qualidade e são formalmente adotadas elas se tornam
                        um padrão de codificação. O escopo de um padrão de codificação abrange os seguintes elementos de código, dentre outros:
                        nomes de arquivos, organização do conteúdo de arquivos, indentação, comentários, declarações de variáveis, espaços em branco,
                        convenção de nomes, etc.
                    </p>

                    <h2 id="padrao-codificao-backend" style="padding-bottom: 0px;">Padrão de Codificação de <i>Back-end</i> (Java)</h2>
                    <hr>

                    <h3 id="arquivos-codigo-fonte" style="padding-bottom: 0px;">Arquivos de código-fonte</h3>
                    <hr>
                    <h4 id="nome-arquivo" style="padding-bottom: 0px;">Nome de arquivo</h4>
                    <p>
                        O nome de um arquivo de código-fonte consiste no nome <i>case-sensitive</i> da classe <i>top-level</i> que ele contém
                        (haverá exatamente uma) acrescido da extensão ".java".
                    </p>
                    <h4 id="codificacao-arquivo" style="padding-bottom: 0px;">Codificação de arquivo</h4>
                    <p>
                        A codificação dos arquivos de código-fonte será a UTF-8.
                    </p>
                    <h3 id="estrutura-arquivos-codigo-fonte" style="padding-bottom: 0px;">Estrutura de arquivos de código-fonte</h3>
                    <hr>
                    <p>
                        Um arquivo de código-fonte consiste das seguintes seções, nessa ordem:
                        <ol>
                            <li>Instrução <i>package</i></li>
                            <li>Instruções <i>import</i></li>
                            <li>Exatamente uma declaração de classe <i>top-level</i></li>
                        </ol>
                        Exatamente uma linha em branco separará uma seção da outra. 
                    </p>
                    <h4 id="instrucao-package" style="padding-bottom: 0px;">Instrução <i>package</i></h4>
                    <p>
                        A instrução <i>package</i> não conterá quebra de linha. O limite de tamanho de coluna não se aplica a essa instrução. 
                    </p>
                    <h4 id="instrucoes-import" style="padding-bottom: 0px;">Instruções <i>import</i></h4>
                    <p>
                         As instruções <i>import</i> não devem conter caracteres-curinga (*). Elas também não conterão quebras de linha, não se
                         aplicando o limite de tamanho de coluna. Não deverá haver instruções <i>imports</i> de elementos não utilizados pelo
                         código-fonte. Elas serão dispostas em grupos na seguinte ordem:
                         <ul>
                             <li><i>Imports</i> estáticos ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em java ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em javax ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em org ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em com ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados com prefixos diferentes dos anteriores ordenados alfabeticamente</li>
                         </ul>
                         Cada grupo acima é separado do outro por uma linha em branco. Essa organização acima já é a padrão realizada pelo Eclipse
                         ao executar o comando <i>"Organize imports"</i>.
                    </p>
                    <h4 id="declaracao-classe" style="padding-bottom: 0px;">Declaração de classe</i></h4>
                    <p>
                         Cada arquivo conterá apenas uma declaração de classe <i>top-level</i>. 
                    </p>
                    <h5 id="ordem-membros-classe" style="padding-bottom: 0px;">Ordem dos membros da classe</h5>
                    <p>
                        A ordem dos membros da classe deve ser a seguinte:
                        <ul>
                            <li>Campos estáticos</li>
                            <li>Campos de instância</li>
                            <li>Construtores</li>
                            <li>Métodos privados chamados por todos os construtores</li>
                            <li>Métodos-fábrica estáticos</li>
                            <li>Propriedades <i>JavaBean</i> (<i>getters</i> e <i>setters</i>)</li>
                            <li>Implementações de métodos oriundas de <i>interfaces</i></li>
                            <li>Métodos privados ou protegidos que são chamados por implementações de métodos oriundos de interfaces</li>
                            <li>Outros métodos</li>
                            <li>Métodos <i>equals</i>, <i>hashCode</i> e <i>toString</i></li>
                        </ul>
                        Os métodos privados devem ser colocados imediatamente abaixo do método que os referencia. 
                    </p>
                    <h3 id="formatacao" style="padding-bottom: 0px;">Formatação</h3>
                    <hr>
                    <h4 id="formatacao-indentacao" style="padding-bottom: 0px;">Indentação</h4>
                    <p>
                        Cada nível de indentação deve conter 4 espaços em branco. Tabs não deverão ser utilizados para esse propósito.
                    </p>
                    <h4 id="formatacao-instrucoes" style="padding-bottom: 0px;">Uma instrução por linha</h4>
                    <p>
                        Cada instrução deverá ser seguida de uma quebra de linha.
                    </p>
                    <h4 id="formatacao-espacos-branco" style="padding-bottom: 0px;">Espaços em branco</h4>
                    <p>
                        Uma linha em branco deverá aparecer:
                        <ul>
                            <li>
                                Entre membros consecutivos (ou inicializadores) de uma classe: campos, construtores, métodos, classes aninhadas,
                                inicializadores estáticos, inicializadores de instância.
                            </li>
                            <li>
                                Entre instruções, conforme necessidade, para organizar o código em subseções lógicas.
                            </li>
                            <li>
                                <i>Opcionalmente</i> antes do primeiro membro ou depois do último membro da classe.
                            </li>
                        </ul>
                    </p>
                    <h4 id="formatacao-chaves" style="padding-bottom: 0px;">Chaves</h4>
                    <p>
                        Construções similares a bloco (corpo de classe, método ou construtor) devem seguir o estilo de
                        Kernighan & Ritchie (também conhecido como chaves egípcias):
                        <ul>
                            <li>Nenhuma quebra de linha antes da chave de abertura mas um único espaço antes dela</li>
                            <li>Quebra de linha após a chave de abertura</li>
                            <li>Quebra de linha antes da chave de fechamento</li>
                            <li>Quebra de linha depois da chave de fechamento caso ela termine uma instrução ou o corpo
                                de um método, construtor, inicializador estático, inicializador de instância ou classe nomeada
                            </li>
                            <li>Nenhuma quebra de linha depois da chave caso ela seja seguida de <i>else</i>, <i>catch</i>, <i>finally</i>
                                ou ponto e vírgula 
                            </li>
                        </ul>
                        Exemplo:
                        <pre class="prettyprint pln">
return new MinhaClasse() {
    @Override
    public void metodo() {
        if (condicao()) {
            fazerAlgo();
        } else {
            try {
                alternative();
            } catch (ProblemException ex) {
                recuperar();
            }
        }
    }
};
</pre>
                    </p>
                    <h4 id="formatacao-quebra-linha" style="padding-bottom: 0px;">Quebras de linha</i></h4>
                    <p>
                        O limite de tamanho de coluna é de 100 caracteres. Ao quebrar expressões grandes, coloque os símbolos separadores no fim
                        da linha ao invés de na próxima linha. Deverão ser adicionados 2 níveis de indentação a uma linha quebrada. Por exemplo:
                        <pre class="prettyprint pln">
if (chamadaDeMetodo1(param1, param2) && chamadaDeMetodo2() && chamadaDeMetodo3() &&
        chamadaDeMetodo4()) {
    // ...
}
</pre>
                    </p>
                    <h5 id="formatacao-quando-quebrar" style="padding-bottom: 0px;">Quando quebrar</h5>
                    <p>
                        A seguir estão algumas diretrizes de quando quebrar a linha:
                        <ul>
                            <li>
                                Métodos e construtores devem ter o parênteses de abertura na mesma linha, mesmo que ultrapassem o limite de tamanho
                                de coluna.
                            </li>
                            <li>
                                Quando uma linha for quebrada em uma expressão de atribuição, a quebra deve ocorrer após o símbolo de igual.
                            </li>
                            <li>
                                Em blocos <i>multi-catch</i>, o operador <code>|</code> deve aparecer antes da quebra de linha.
                            </li>
                        </ul>
                    </p>
                    <h5 id="formatacao-blocos-vazios" style="padding-bottom: 0px;">Blocos vazios</h5>
                    <p>
                        <i>Opcionalmente</i> um bloco vazio pode ser fechado imediatamente depois de ser aberto, sem nenhum caracter ou quebra de linha entre as chaves,
                        a não ser que seja uma instrução de multi-bloco (uma que contém múltiplos blocos <code>if/else-if/else</code> ou
                        <code>try/catch/finally</code>)
                        Exemplo:
                        <pre class="prettyprint pln">
void metodo() {}
</pre>
                    </p>
                    <h4 id="nomeacao" style="padding-bottom: 0px;">Nomeação</h4>
                    <h5 id="nomeacao-identificadores" style="padding-bottom: 0px;">Identificadores</h5>
                    <p>
                        Os identificadores devem seguir as <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">regras do Java</a>.
                        Evite utilizar identificadores com apenas um caracter. Por exemplo, prefira <code>Method metodo</code> a <code>Method m</code> (uma 
                        exceção a essa recomendação é a já tradicional utilização de <code>i</code>, <code>j</code>, <code>k</code>, etc como identificadores de contadores, especialmente
                        em instruções <code>for</code>)
                    </p>
                    <h5 id="nomeacao-constantes" style="padding-bottom: 0px;">Constantes</h5>
                    <p>
                        Nomes de constantes utilizam todas suas letras em maiúsculas com as palavras separadas por <i>underscore</i> (<code>CONSTANT_CASE</code>).
                        Toda constante é um campo com os modificadores <code>static</code> e <code>final</code>, porém nem todos os campos com esses
                        modificadores são constantes. Um campo <code>static final</code> cujo estado observável pode mudar certamente não pode
                        ser considerado uma constante. Por exemplo:
                        <pre class="prettyprint pln">
// Constantes
private static final Object NULL_HOLDER = new NullHolder();
public static final int DEFAULT_PORT = -1;

// Não são constantes
private static final ThreadLocal<Executor> executorHolder = new ThreadLocal<Executor>();
private static final Set<String> internalAnnotationAttributes = new HashSet<String>();
                        </pre>
                    </p>
                    <h5 id="nomeacao-pacotes" style="padding-bottom: 0px;">Pacotes</h5>
                    <p>
                        Nomes de pacotes devem estar com todas as letras em minúsculo, com palavras consecutivas apenas concatenadas,
                        sem <i>underscore</i> entre elas. Por exemplo, <code>br.jus.stf.plataforma.userauthentication</code>, mas não
                        <code>br.jus.stf.plataforma.userAuthentication</code> ou <code>br.jus.stf.plataforma.user_authentication</code>.
                    </p>
                    <h5 id="nomeacao-classes" style="padding-bottom: 0px;">Classes</h5>
                    <p>
                        Os nomes de classes devem ser escritos em <code>UpperCamelCase</code>. Nomes de classe são tipicamente substantivos ou
                        substantivos seguidos de qualificadores. Por exemplo, <code>Anexo</code> ou <code>ClassePeticionavel</code>.
                        Nomes de interfaces também podem ser substativos ou substantivos seguidos de qualificadores (por exemplo, <i>List</i>),
                        além de adjetivos (por exemplo, <code>Peticionavel</code>).
                    </p>
                    <p>
                        Classes de teste unitário devem iniciar com o nome da classe que estão testando seguido de <code>UnitTests</code>. Por exemplo,
                        <code>PecaUnitTests</code>. Classes de teste de integração devem iniciar com o nome da funcionalidade seguido de <code>IntegrationTests</code>.
                        Por exemplo, <code>ProcessoOriginarioIntegrationTests</code>.
                    </p>
                    <h5 id="nomeacao-metodos" style="padding-bottom: 0px;">Métodos</h5>
                    <p>
                        Nomes de métodos devem ser escritos em <code>lowerCamelCase</code>. Nomes de métodos são tipicamente verbos ou
                        verbos seguidos de qualificadores. Por exemplo, <code>handle</code> ou <code>autuarRecursal</code>.
                    </p>
                    <h5 id="nomeacao-campos" style="padding-bottom: 0px;">Campos</h5>
                    <p>
                        O nome de campos não constantes (estáticos ou não) devem ser escritos em <code>lowerCamelCase</code>. Esses nomes são normalmente
                        substantivos ou substantivos seguidos de qualificadores. Por exemplo, <code>numeroProcesso</code> ou <code>peticao</code>.
                    </p>
                    <h5 id="nomeacao-parametros" style="padding-bottom: 0px;">Parâmetros</h5>
                    <p>
                        Os nomes de parâmetros de métodos devem ser escritos em <code>lowerCamelCase</code>.
                        Nomes de parâmetros com apenas um caracter devem ser evitados em métodos públicos.
                    </p>
                    <h5 id="nomeacao-variaveis-locais" style="padding-bottom: 0px;">Variáveis locais</h5>
                    <p>
                        Os nomes de variáveis locais devem ser escritos em <code>lowerCamelCase</code>. Mesmo quando finais e imutáveis,
                        variáveis locais não são consideradas constantes e não devem ter seus nomes em <code>CONSTANT_CASE</code>.
                    </p>
                    <h5 id="nomeacao-variaveis-tipo" style="padding-bottom: 0px;">Variáveis de tipo parametrizado</h5>
                    <p>
                        Os nomes das variáveis de tipo parametrizado devem ser escritos com uma única letra maiúscula,
                        opcionalmente seguida de um único numeral (por exemplo, <code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)
                    </p>
                    <h3 id="praticas-programcao" style="padding-bottom: 0px;">Boas práticas de programação</h3>
                    <hr>
                    <h4 id="utilizacao-override" style="padding-bottom: 0px;">Utilização de <code>@Override</code></h4>
                    <p>
                        Um método deve ser anotado com <code>@Override</code> sempre que esse método estiver sobreescrevendo um método de uma
                        classe pai ou implementando um método de uma interface.
                    </p>
                    <h4 id="metodos-setter" style="padding-bottom: 0px;">Métodos <i>setter</i></h4>
                    <p>
                        Crie métodos <i>setters</i> apenas se eles realmente forem necessários. A ordem dos <i>setters</i> deve refletir sua importância e
                        não apenas a ordem histórica de inclusão. Além disso, essa ordem deverá ser consistente com a ordem dos campos. 
                    </p>
                    <h4 id="operador-ternario" style="padding-bottom: 0px;">Operador ternário</h4>
                    <p>
                        Sempre coloque o operador ternário entre parênteses. Por exemplo:
                        <pre>
return (foo != null ? foo : "default");
</pre>
                    </p>
                    <h3 id="praticar-ddd" style="padding-bottom: 0px;">Práticas do Domain-Driven Design</h3>
                    <hr>
                    <h4 id="classes-dominio" style="padding-bottom: 0px;">Classes de domínio</h4>
                    <p>
                        A seguir estão algumas regras gerais sobre práticas recomendadas nas classes de domínio:
                        <ul>
                            <li>
                                Os nomes das classes devem refletir a <a href="http://martinfowler.com/bliki/UbiquitousLanguage.html">linguagem ubíqua</a>
                                baseada no modelo de domínio.
                            </li>
                            <li>
                                Não deverão ser usados métodos <i>getters</i> iniciando com <code>get</code>. Tais métodos deverão
                            ser nomeados com apenas o nome da propriedade de negócio que ele representa. Por exemplo:
<pre>public PessoaId pessoa() {
    return pessoa;
}
</pre></li>
                            <li>
                                Não deverão existir métodos <i>setters</i> para simplesmente alterar um estado de um objeto de domínio. A alteração de seu
                                estado deverá ocorrer por meio de métodos com nomes que reflitam a linguagem ubíqua adotada. Por exemplo:
<pre>
public void autuar(Classe classe, Long numero, Set<Parte> partes, Autuador autuador, Status status) {
    identificar(classe, numero);
    autuar(partes, autuador, status);
}
</pre>
                            </li>
                        </ul>
                    </p>
                </div>
    
            </div>
            <!-- end jd-content -->
        </div>
        <!--/#body-content-->
    </body>
</html>