<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
        <meta content="IE=edge" http-equiv="X-UA-Compatible">
        
        <title>STF Digital Developers | Testes</title>
        
        <!-- STYLESHEETS -->
        <link rel="stylesheet" href="assets/styles/fonts.css" type="text/css" >
        <link rel="stylesheet" href="assets/styles/fonts1.css" title="roboto" type="text/css">
        
        <link href="assets/styles/default.css" rel="stylesheet" type="text/css">
    </head>

    <body class="gc-documentation develop guide  dac-nav-open" itemscope="" itemtype="http://schema.org/Article">
        <header id="header-wrapper">
            <div class="dac-header" id="header">
                <div class="dac-header-inner">
                    <a class="dac-nav-toggle" data-dac-toggle-nav="" href="../index.html" title="Open navigation"> 
                        <span class="dac-nav-hamburger"> 
                            <span class="dac-nav-hamburger-top"></span> 
                            <span class="dac-nav-hamburger-mid"></span> 
                            <span class="dac-nav-hamburger-bot"></span>
                        </span>
                    </a>
                    <a class="dac-header-logo" href="../index.html">
                        <img class="dac-header-logo-image" src="../assets/images/logo.png" srcset="../assets/images/logo.png" width="32" height="32">STF Digital
                    </a>
                    <ul class="dac-header-tabs">
                        <li><a class="dac-header-tab selected" href="#">Desenvolvimento</a></li>
                    </ul>
                    <a class="dac-header-console-btn" href="https://github.com/supremotribunalfederal/stfdigital" target="_blank" > 
                        <img src="../assets/images/github-icon.png" srcset="../assets/images/github-icon.png" />
                        <span class="dac-visible-desktop-inline">Repositório</span>
                    </a>
                </div>
            <!--/.header-wrap.wrap-->
            </div>
        <!--/.header-->
        </header>
    
        <a name="navigation" tabindex="0" class="nav-start-marker">navigation</a>

        <nav class="dac-nav">
            <div class="dac-nav-dimmer" data-dac-toggle-nav=""></div>
            <div class="dac-nav-sidebar" data-swap="" data-dynamic="false" data-transition-speed="300" data-dac-nav="">
                <div data-swap-container="">
                    <a class="dac-nav-back-button dac-swap-section dac-up dac-active" tabindex="0" data-swap-button="" href="../index.html"> 
                        <i class="dac-sprite dac-nav-back"></i> 
                        <span class="dac-nav-back-title">Arquitetura</span>
                    </a>
    
                    <div class="dac-nav-sub dac-swap-section dac-right dac-active">
                        <ul id="nav">
                            <li class="nav-section expanded">
                                <div class="nav-section-header">
                                    <a href="#">Iniciando</a>
                                </div>
                                <ul style="display: block;">
                                    <li><a href="../iniciando/definicao.html">O que é o STF Digital</a></li>
                                    <li><a href="../iniciando/montagem.html">Monte seu Ambiente</a></li>
                                    <li><a href="../iniciando/demonstracao.html">Demonstração</a></li>
                                </ul>
                            </li>
                            </br>
                            <li class="nav-section expanded">
                                <div class="nav-section-header">
                                    <a href="#">Arquitetura</a>
                                </div>
                                <ul style="display: block;">
                                    <li><a href="../arquitetura/visao.html">Nossa Visão</a></li>
                                    <li><a href="../arquitetura/estrategia.html">Estratégia Arquitetural</a></li>
                                    <li><a href="../arquitetura/implantacao.html">Estratégia de Implantação</a></li>
                                </ul>
                            </li>
                            </br>
                            <li class="nav-section expanded">
                                <div class="nav-section-header">
                                    <a href="#">Padrões e Políticas</a>
                                </div>
                                <ul style="display: block;">
                                    <li><a href="../politicas/testes.html">Estratégia de Testes</a></li>
                                    <li><a href="../politicas/api.html">Gestão da API</a></li>
                                    <li><a href="../politicas/codigo-limpo.html">Código Limpo</a></li>
                                    <li><a href="../politicas/diretorios.html">Estrutura de diretórios</a></li>
                                </ul>
                            </li>
                        </ul>
                    </div>
    
                </div>
            </div>
        </nav>

        <a name="top" tabindex="0"></a>
    
        <div class="wrap clearfix" id="body-content">
            <div class="content-header">
                <ul class="dac-header-crumbs dac-has-content">
                    <li class="dac-header-crumbs-item"><a class="dac-header-crumbs-link" href="#">Desenvolvimento</a></li>
                    <li class="dac-header-crumbs-item"><a class="dac-header-crumbs-link" href="#">Arquitetura</a></li>
                    <li class="dac-header-crumbs-item"><a class="dac-header-crumbs-link" href="#">Estratégia</a></li>
                </ul>
                <h1 itemprop="name">Código Limpo</h1>
            </div>
            <div id="jd-content">
                <div class="jd-descr" itemprop="articleBody">
                    <div id="qv-wrapper">
                        <div id="qv">
                            <h2>Neste documento</h2>
                            <ol>
                                <li>
                                    <a href="#excecoes">Tratamento de Exceções</a>
                                </li>
                                <li>
                                    <a href="#padrao-codificacao">Padrão de Codificação</a>
                                    <ol>
                                        <li><a href="#padrao-codificao-backend">Padrão de Codificação de Back-end</a></li>
                                        <li><a href="#padrao-codificao-frontend">Padrão de Codificação de Front-end</a></li>
                                    </ol>
                                </li>
                                <li>
                                    <a href="#metricas-qualidade">Métricas de qualidade</a>
                                </li>
                            </ol>
                        </div>
                    </div>
    
                    <p>
                        <i>Segundo Robert C. Martin, uma das principais referências na área, "código limpo não é somente 
                        desejável - é necessário. Se o código não estiver limpo, o desenvolvimento decai com o tempo. 
                        Eventualmente, chega a um tal ponto de incerteza, dor e frustração que parece ser mais 
                        fácil começar de novo e reescrever tudo do início. Obviamente que se a reescrita não for 
                        melhor que o original, o problema persiste, e em pouco tempo a equipe acaba onde 
                        tinha começado".</i> 
                    </p>
                        
                    <p>
                        <i>É claro que a definição do que é código limpo depende das preferências pessoais de cada um, mas
                        tentamos descrever aqui um conjunto de recomendações para garantir a qualidade do código e assim
                        facilitar a manutenção, quebrar os ciclos de reescrita e extrair do código o melhor para 
                        os usuários e para os desenvolvedores.</i> 
                    </p>
                        
                    <h2 id="excecoes" style="padding-bottom: 0px;">Tratamento de Exceções</h2>
                    <hr>
    
                    <p>
                        Exceções foram introduzidas na linguagem Java para garantir resiliência e confiabilidade.
                        O objetivo seria assegurar que os sistemas pudessem reagir apropriadamente a situações
                        inesperadas e a contigências específicas. Embora seu propósito seja simples, a forma de utilização 
                        sempre gerou muita confusão. Abaixo, listamos um conjunto de práticas que devem sempre 
                        ser observadas ao lidar com exceções.
                    </p>  
    
                    <h4 id="excecoes" style="padding-bottom: 0px;">Tipos de Exceções</h4>
                    <hr>
    
                    <p>
                        Há grande controvérsia envolvendo o uso de <i>Checked Exceptions</i>, com personalidades
                        como Rod Johnson (criador do Spring Framework) e Gavin King (criador do Hibernate) se
                        posicionando contra seu uso. De fato, Spring, Hibernate e vários outros frameworks
                        estão usando apenas <i>Unchecked Exceptions</i>.
                    </p>

                    <p>
                        <i>Checked Exceptions</i>, implementadas em Java como uma subclasse de <i>Exception</i>
                        foram inicialmente propostas para situações em que o cliente da API pode se recuperar
                        do problema indicado pela exceção. O problema é que essas situações são muito raras.
                        Em geral, seu código não terá a capacidade de se recuperar de uma situação problemática.
                        Quando usada como recomendação padrão, esse tipo de exceção pode levar a problemas
                        de encapsulamento e problemas graves de manutenção. Suponha, por exemplo, que 
                        uma exceção dessas é incluída na API de uma biblioteca de baixo nível. Caso não 
                        seja uma exceção recuperável, essa modificação poderá impactar toda a cadeia
                        de chamadas que termina na chamada dessa API, forçando a inclusão de blocos 
                        "try-catch" ou a inclusão de instruções "throws" em toda a sequência de processamento.
                    </p>
    
                    <p>
                        <i>Unchecked Exceptions</i>, implementadas em Java como uma subclasse de <i>RuntimeException</i>,
                        por outro lado, foram propostas para situações em que o cliente da API não pode se recuperar.
                        Elas podem ser lançadas de qualquer ponto, em qualquer lugar, não exigem declaração e não
                        demandam tratamento. São muito mais convenientes e, por isso, muito mais populares. 
                    </p>
    
                    <p>
                        Recomendamos usar <i>Unchecked Exceptions</i> como escolha padrão e somente naqueles raros casos em
                        que há inquestinável possibilidade de recuperação pelo cliente da API, usar <i>Checked Exceptions</i>.  
                        Portanto, se cliente do método pode tomar alguma ação para se recuperar de um erro esperado, então crie sua
                        exceção como uma <i>Checked Exceptions</i>. Caso contrário, se o cliente não pode fazer nada
                        útil no caso de um erro, então crie sua exceção como uma <i>Unchecked Exceptions</i>.
                    </p>
    
                    <h4 id="hierarquia" style="padding-bottom: 0px;">Hierarquia de Exceções</h4>
                    <hr>

                    <p>
                        Defina sua própria hierarquia de exceções. Ao fazer isso, você poderá utilizar esses tipos
                        para implementação do mecanismo de tratamento de erros que poderá, por exemplo,
                        registrar informações específicas das exceções. Use os tipos de exceções claramente,
                        para definir a causa raiz do problema e eventualmente a severidade do erro (fatal,
                        warn, info, debug).    
                    </p>
                        
                    <h4 id="fluxo" style="padding-bottom: 0px;">Controle de Fluxo</h4>
                    <hr>

                    <p>
                        Exceções não devem ser usadas para controle de fluxo. Não gerencie lógica de negócio com exceções.
                        Use instruções condicionais para isso. Lançar e tratar exceções são operações onerosas.
                        Se o controle pode ser feito com uma instrução condicional, não use exceções porque isso 
                        impacta significativamente a performance geral do sistema, além de reduzir a legibilidade
                        do código. Por exemplo, se um método retorna null, use <a href="https://dzone.com/articles/java-8-optional-replace-your-get-calls">Optionals</a> ou
                        uma instrução <i>if-else</i> em vez de depender do tratamento de exceções para fazer 
                        esse tipo de verificação.
                    </p>

                    <p>
                        Exceções têm um impacto sobre o desempenho global do aplicativo, então devem ser usadas criteriosamente. 
                        Não use exceções se você pode usar uma variável boleana para verificar se uma operação foi 
                        bem-sucedida ou não. Tente sempre retornar uma variável para que o cliente do código 
                        possa controlar o fluxo de execução com base nesse retorno.
                    </p>

                    <p>
                        Identifique e corrija a causa raiz dos problemas para evitar tratamentos desnecessários. 
                        Sempre faça as validações das variáveis que possam assumir valores null antes de executar
                        as operações, verifique o tamanho do array em vez de confiar em ArrayIndexOutOfBoundException.
                    </p>

                    <p>
                        Lance exceçõs para possíveis erros reportados por um método. Por exemplo, se você retorna os
                        valores -1, -2, -3... invés de FileNotFoundException, esse método pode não ser bem
                        entendido.
                    </p>

                    <p>
                        Usar o tratamento de exceções dentro de um loop não é recomendado para muitos casos. 
                        Tente colocar o loop dentro do bloco de tratamento das execeções
                    </p>
                        
                    <h4 id="lancamento" style="padding-bottom: 0px;">Lançamento</h4>
                    <hr>

                    <p>
                        É sempre melhor lançar exceções específicas em vez de lançar exceções mais genéricas, como
                        <i>Throwable</i>, <i>Excpetion</i> or <i>RuntimeException</i>. Ao fazer isso, nós podemos fornecer
                        mais informações sobre o que exatamente ocorreu e o código fica mais legível.
                    </p>

                    <p>                         
                        Sempre que precisar lançar uma exceção, siga o princípio <i>Throw Early or Fail-Fast</i>. A <i>stack trace</i>
                        de uma exceção mostra a sequência exata de chamadas de métodos até o ponto em que ocorreu a exceção,
                        incluindo o nome da classe, o nome do arquivo e o número da linha onde a exceção foi lançada. Por isso,
                        é muito importante lançar a exceção o quanto antes, imediatamente quando a exceção é detectada.
                        Por exemplo, se o erro ocorre em um método mais não é lançada por ele, mas sim pelo método chamado,
                        a <i>stack trace</i> não indicará o posição exata do erro, o que poderá comprometer o tempo de
                        diagnóstica da causa do problema.
                    </p>
                        
                    <h4 id="tratamento" style="padding-bottom: 0px;">Tratamento</h4>
                    <hr>

                    <p>
                        <i>Throwable</i> é a superclasse de todos os erros e exceções em Java. <i>Error</i> é a superclasse
                        de todos os erros capturáveis por qualquer aplicação. Tratar <i>Throwable</i> ou <i>Error</i> significa que
                        erros como OutOfMemoryError, StackOverFlowError e etc. significa que sua aplicação poderia se
                        recuperar de situações como essas, o que obviamente não é possível. Assim, <i>Throwable</i>
                        ou <i>Error</i> não devem ser capturadas porque não há tratamento possível para elas.
                    </p>

                    <p>
                        Sempre faça o tratamento de exceções específicas, nunca de exceções genéricas como <i>Exception</i>. 
                        Não é possível se recuperar de erro que você não conhece, um erro genérico. Só podemos tentar um 
                        outro caminho se conhecemos exatamente qual problema ocorreu. Além de viabilizar
                        o tratamento de um erro específico, isso evita problemas de performance e ainda garante maior 
                        legibilidade do código.
                    </p>

                    <p>
                        Sempre que precisar tratar uma exceção, siga o princípio <i>Catch Late</i>. No caso de <i>checked 
                        exceptions</i>, o compilador Java força que o cliente capture a exceção ou a declare usando a cláusula
                        <i>throws</i>. Assim, geralmente os desenvolvedores tendem a capturar a exceção e não fazer nada
                        além de registrar a <i>stacktrace</i> para evitar erros de compilação. Mas, ao fazer isso
                        você estará escondendo o que realmente aconteceu. É melhor capturar a exceção somente
                        quando ele poderá ser tratada apropriadamente. Use a cláusula <i>throws</i> para declarar
                        a exceção e passar a responsabilidade para o método chamador. Dessa forma, caso nenhum dos 
                        métodos acima conseguir tratar a exceção apropriadamente, ela alcançará o mecanismo de 
                        tratamento global de exceções, cuja responsabilidade é tratar casos como esse.
                    </p>

                    <p>
                        Novamente, não esconda a exceção! Não substitua o tratamento de exceções por um bloco vazio, o registro da 
                        <i>stacktrace</i> ou da exceção, como nas listagens abaixo. Ignorar exceções poderá evitar erros de compilação, 
                        mas vai criar um caos a manutenção posterior.
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">try</span><span class="pln"> {</span> <span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">/* ... */</span></br><span class="str">catch</span><span class="pln"> (Exception e) {</span><span class="pln"><br></span><span class="pln"></span><span class="pln"><br></span><span class="pln">}</span></pre>
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">try</span><span class="pln"> {</span> <span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">/* ... */</span></br><span class="str">catch</span><span class="pln"> (Exception e) {</span><span class="pln"><br></span><span class="pln"></span><span class="pln">&nbsp; &nbsp;LOGGER.info("Erro inesperado");</span><br><span class="pln">}</span></pre>
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">try</span><span class="pln"> {</span> <span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">/* ... */</span></br><span class="str">catch</span><span class="pln"> (Exception e) {</span><span class="pln"><br></span><span class="pln"></span><span class="pln">&nbsp; &nbsp;e.printStackTrace();</span><br><span class="pln">}</span></pre>
                    </p>

                    <p>
                        Não perca a exceção original. Quase todas as exceções fornecem um construtor com um parâmetro para a causa.
                        Ao criar uma exceção customizada, lembre-se de incluir esse construtor.
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">public </span><span class="pln">Exception(String message, Throwable cause)</span> </pre>
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">catch</span><span class="pln"> (IllegalArgumentException exp) {</span></br><span class="pln"></span><span class="str">&nbsp; &nbsp;throw new </span><span class="pln">throw new MyCustomException("Mensagem específica" , exp);</span></br><span class="pln">}</span></pre>
                    </p>

                    <h4 id="logging" style="padding-bottom: 0px;">Logging</h4>
                    <hr>

                    <p>
                        Não log a mesma exceção mais de uma vez, para não haver confusão em relação à localização da exceção.
                        Nós deveríamos sempe logar a mensagem da exceção e essa mensagem dever conter informações precisas
                        para que o chamador possa saber facilmente o que ocorreu. Sempre usa informações detalhadas, 
                        adicionando os valores de varáiveis relevantes quando possível. Por exemplo, se nós estamos
                        escrevendo um código em que uma regra só é aplicada para idosos, 
                        se a idade é menor que 60, então o método dever lançar InvalidAgeException.
                        Nesse caso, se a exceção é lançada sem especificar qual a idade do cidadão, a mensagem pode não ser
                        tão útil quanto no caso em que você informa exatamente que idade causou a exceção.
                    </p>

                    <p>
                        <pre class="prettyprint"><span class="str">catch</span><span class="pln"> (NoSuchFieldException exp) {</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">LOGGER.error("Exception occurred", exp);</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pln">throw exp;</span><span class="pln"><br></span><span class="pln">}</span></pre>

                        Logar e lançar uma exceção dentro de um bloco catch é considerado anti-pattern e deveira ser
                        evitado. Logar e lançar a exceção pode resultar em múltiplas mensagens de erro no arquivo de log 
                        para um único problema, dificultando o trabalho dos responsáveis por identificar 
                        e diagnosticar problemas no código.
                    </p>

                    <p>
                        Por fim, lembre-se que granularidade é muito importante. Um bloco de tratamento deve tratar sempre um caso
                        específico. Não coloque centenas de linhas de código dentro de um bloco <i>try-catch</i>. 
                    </p>
                        
                    <h4 id="documentacao" style="padding-bottom: 0px;">Documentação</h4>
                    <hr>

                    <p>
                        Atribuir um código para cada diferente mensagem de exceção é uma boa prática para documentação porque
                        facilita muito a comunicação do tipo de erro. Também recomendamos usar Javadoc @throws para indicar 
                        as exceções lançadas pelos métodos. Isso facilita bastante principalmente no caso de interfaces 
                        que poderá ser usadas em outras aplicações.
                    </p>    

                    <h4 id="nomenclatura" style="padding-bottom: 0px;">Nomenclatura</h4>
                    <hr>

                    <p>
                        O nome das exceções deve ser claro e significativo para comunicar objetivamente qual a causa da exceção.
                        Ao criar suas próprias exceções, siga o padrão já definido pela linguagem. Inicie o nome com a causa
                        e termine com o sufixo <i>Excpetion</i>, como <i>NoSuchMethodExcpetion</i>.
                    </p>    
                        
                    <p>
                        Lembre-se de manter exceções de mesmo tipo dentro da mesma hierarquia. Por exemplo, exceções
                        relacionadas a problemas de IO são todas subclasses de <i>IOExcpetion</i>.
                    </p>    

                    <h2 id="padrao-codificacao" style="padding-bottom: 0px;">Padrão de Codificação</h2>
                    <hr>

                    <p>
                        A utilização de um padrão de codificação é importante para reduzir o custo de manutenção do <i>software</i>, já que sua
                        adoção melhora a legibilidade dele. A Sun Microsystems, em seu documento de <i>Convenções de código para a linguagem
                        de programação Java</i>, cita algumas das razões por que convenções de codificação são importantes: 
                        <ul>
                            <li>80% do custo de um <i>software</i> durante seu ciclo de vida é dedicado à manutenção.</li>
                            <li>Dificilmente um <i>software</i> é mantido pelo mesmo desenvolvedor por todo seu ciclo de vida.</li>
                            <li>Padrões de codificação melhoram a legibilidade do código, permitindo que os desenvolvedores
                                entendam novos códigos de forma mais rápida e completa.
                        </ul>
                        Quando convenções de código são projetadas para produzir código de alta qualidade e são formalmente adotadas elas se tornam
                        um padrão de codificação. O escopo de um padrão de codificação abrange os seguintes elementos de código, dentre outros:
                        nomes de arquivos, organização do conteúdo de arquivos, indentação, comentários, declarações de variáveis, espaços em branco,
                        convenção de nomes, etc.
                    </p>

                    <h2 id="padrao-codificao-backend" style="padding-bottom: 0px;">Padrão de Codificação de <i>Back-end</i> (Java)</h2>
                    <hr>
                    <ol>
                        <li>
                            <a href="#arquivos-codigo-fonte">Arquivos de código-fonte</a>
                            <ol>
                                <li><a href="#nome-arquivo">Nome de arquivo</a></li>
                                <li><a href="#codificacao-arquivo">Codificação de arquivo</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#estrutura-arquivos-codigo-fonte">Estrutura de arquivos de código-fonte</a>
                            <ol>
                                <li><a href="#instrucao-package">Instrução package</a></li>
                                <li><a href="#instrucoes-import">Instruções import</a></li>
                                <li>
                                    <a href="#declaracao-classe">Declaração de classe</a>
                                    <ol>
                                        <li><a href="#ordem-membros-classe">Ordem dos membros da classe</a></li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#formatacao">Formatação</a>
                            <ol>
                                <li><a href="#formatacao-indentacao">Indentação</a></li>
                                <li><a href="#formatacao-instrucoes">Uma instrução por linha</a></li>
                                <li><a href="#formatacao-espacos-branco">Linhas em branco</a></li>
                                <li><a href="#formatacao-chaves">Chaves</a></li>
                                <li>
                                    <a href="#formatacao-quebra-linha">Quebras de linha</a>
                                    <ol>
                                        <li><a href="#formatacao-quando-quebrar">Quando quebrar</a></li>
                                        <li><a href="#formatacao-blocos-vazios">Blocos vazios</a></li>
                                        <li><a href="#formatacao-lambda">Lambdas</a></li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#nomeacao">Nomeação</a>
                            <ol>
                                <li><a href="#nomeacao-identificadores">Identificadores</a></li>
                                <li><a href="#nomeacao-constantes">Constantes</a></li>
                                <li><a href="#nomeacao-pacotes">Pacotes</a></li>
                                <li><a href="#nomeacao-classes">Classes</li>
                                <li><a href="#nomeacao-metodos">Métodos</a></li>
                                <li><a href="#nomeacao-campos">Campos</a></li>
                                <li><a href="#nomeacao-parametros">Parâmetros</a></li>
                                <li><a href="#nomeacao-variaveis-locais">Variáveis locais</a></li>
                                <li><a href="#nomeacao-variaveis-tipo">Variáveis de tipo parametrizado</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#comentarios">Comentários</a>
                        </li>
                        <li>
                            <a href="#javadoc">Javadoc</a>
                            <ol>
                                <li><a href="#javadoc-formatacao">Formatação</a></li>
                                <li><a href="#javadoc-clausulas-at">Cláusulas @</a></li>
                                <li><a href="#javadoc-quando-utilizar">Quando utilizar</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#praticas-programacao">Boas práticas de programação</a>
                            <ol>
                                <li><a href="#utilizacao-override">Utilização de @Override</a></li>
                                <li><a href="#metodos-setter">Métodos setter</a></li>
                                <li><a href="#operador-ternario">Operador ternário</a></li>
                                <li><a href="#referencias-metodo-campo">Referências a métodos e campos</a></li>
                                <li><a href="#documentacao-apis">Documentação de APIs</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#praticas-ddd">Práticas do Domain-Driven Design</a>
                            <ol>
                                <li><a href="#classes-dominio">Classes de domínio</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#formatador-codigo-java">Formatador de código Java</a>
                        </li>
                    </ol>
                    <h3 id="arquivos-codigo-fonte" style="padding-bottom: 0px;">Arquivos de código-fonte</h3>
                    <hr>
                    <h4 id="nome-arquivo" style="padding-bottom: 0px;">Nome de arquivo</h4>
                    <p>
                        O nome de um arquivo de código-fonte consiste no nome <i>case-sensitive</i> da classe <i>top-level</i> que ele contém
                        (haverá exatamente uma) acrescido da extensão ".java".
                    </p>
                    <h4 id="codificacao-arquivo" style="padding-bottom: 0px;">Codificação de arquivo</h4>
                    <p>
                        A codificação dos arquivos de código-fonte será a UTF-8.
                    </p>
                    <h3 id="estrutura-arquivos-codigo-fonte" style="padding-bottom: 0px;">Estrutura de arquivos de código-fonte</h3>
                    <hr>
                    <p>
                        Um arquivo de código-fonte consiste das seguintes seções, nessa ordem:
                        <ol>
                            <li>Instrução <i>package</i></li>
                            <li>Instruções <i>import</i></li>
                            <li>Exatamente uma declaração de classe <i>top-level</i></li>
                        </ol>
                        Exatamente uma linha em branco separará uma seção da outra. 
                    </p>
                    <h4 id="instrucao-package" style="padding-bottom: 0px;">Instrução <i>package</i></h4>
                    <p>
                        A instrução <i>package</i> não conterá quebra de linha. O limite de tamanho de coluna não se aplica a essa instrução. 
                    </p>
                    <h4 id="instrucoes-import" style="padding-bottom: 0px;">Instruções <i>import</i></h4>
                    <p>
                         As instruções <i>import</i> não devem conter caracteres-curinga (*). Elas também não conterão quebras de linha, não se
                         aplicando o limite de tamanho de coluna. Não deverá haver instruções <i>imports</i> de elementos não utilizados pelo
                         código-fonte. Elas serão dispostas em grupos na seguinte ordem:
                         <ul>
                             <li><i>Imports</i> estáticos ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em <code>java</code> ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em <code>javax</code> ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em <code>org</code> ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados em <code>com</code> ordenados alfabeticamente</li>
                             <li><i>Imports</i> dos pacotes iniciados com prefixos diferentes dos anteriores ordenados alfabeticamente</li>
                         </ul>
                         Cada grupo acima é separado do outro por uma linha em branco. Essa organização acima já é a padrão realizada pelo Eclipse
                         ao executar o comando <i>"Organize imports"</i>.
                    </p>
                    <h4 id="declaracao-classe" style="padding-bottom: 0px;">Declaração de classe</h4>
                    <p>
                         Cada arquivo conterá apenas uma declaração de classe <i>top-level</i>. 
                    </p>
                    <h5 id="ordem-membros-classe" style="padding-bottom: 0px;">Ordem dos membros da classe</h5>
                    <p>
                        A ordem dos membros da classe deve ser a seguinte:
                        <ul>
                            <li>Campos estáticos</li>
                            <li>Campos de instância</li>
                            <li>Construtores</li>
                            <li>Métodos privados chamados por todos os construtores</li>
                            <li>Métodos-fábrica estáticos</li>
                            <li>Propriedades <i>JavaBean</i> (<i>getters</i> e <i>setters</i>)</li>
                            <li>Implementações de métodos oriundos de <i>interfaces</i></li>
                            <li>Métodos privados ou protegidos que são chamados por implementações de métodos oriundos de interfaces</li>
                            <li>Outros métodos</li>
                            <li>Métodos <code>equals</code>, <code>hashCode</code> e <code>toString</code></li>
                        </ul>
                        Os métodos privados devem ser colocados imediatamente abaixo do método que os referencia. 
                    </p>
                    <h3 id="formatacao" style="padding-bottom: 0px;">Formatação</h3>
                    <hr>
                    <h4 id="formatacao-indentacao" style="padding-bottom: 0px;">Indentação</h4>
                    <p>
                        Cada nível de indentação deve conter 4 espaços em branco. Tabs não deverão ser utilizados para esse propósito.
                    </p>
                    <h4 id="formatacao-instrucoes" style="padding-bottom: 0px;">Uma instrução por linha</h4>
                    <p>
                        Cada instrução deverá ser seguida de uma quebra de linha.
                    </p>
                    <h4 id="formatacao-espacos-branco" style="padding-bottom: 0px;">Linhas em branco</h4>
                    <p>
                        Uma linha em branco deverá aparecer:
                        <ul>
                            <li>
                                Entre membros consecutivos (ou inicializadores) de uma classe: campos, construtores, métodos, classes aninhadas,
                                inicializadores estáticos, inicializadores de instância.
                            </li>
                            <li>
                                Entre instruções, conforme necessidade, para organizar o código em subseções lógicas.
                            </li>
                            <li>
                                <i>Opcionalmente</i> antes do primeiro membro ou depois do último membro da classe.
                            </li>
                        </ul>
                    </p>
                    <h4 id="formatacao-chaves" style="padding-bottom: 0px;">Chaves</h4>
                    <p>
                        Construções similares a bloco (corpo de classe, método ou construtor) devem seguir o estilo de
                        Kernighan & Ritchie (também conhecido como chaves egípcias):
                        <ul>
                            <li>Nenhuma quebra de linha antes da chave de abertura mas um único espaço antes dela</li>
                            <li>Quebra de linha após a chave de abertura</li>
                            <li>Quebra de linha antes da chave de fechamento</li>
                            <li>Quebra de linha depois da chave de fechamento caso ela termine uma instrução ou o corpo
                                de um método, construtor, inicializador estático, inicializador de instância ou classe nomeada
                            </li>
                            <li>Nenhuma quebra de linha depois da chave caso ela seja seguida de <i>else</i>, <i>catch</i>, <i>finally</i>
                                ou ponto e vírgula 
                            </li>
                        </ul>
                        Exemplo:
                        <pre class="prettyprint pln">
return new MinhaClasse() {
    @Override
    public void metodo() {
        if (condicao()) {
            fazerAlgo();
        } else {
            try {
                alternative();
            } catch (ProblemException ex) {
                recuperar();
            }
        }
    }
};
</pre>
                    </p>
                    <h4 id="formatacao-quebra-linha" style="padding-bottom: 0px;">Quebras de linha</i></h4>
                    <p>
                        O limite de tamanho de coluna é de <b>120</b> caracteres. Ao quebrar expressões grandes, coloque os símbolos separadores no fim
                        da linha ao invés de na próxima linha. Para melhorar a legibilidade em algumas situações, uma linha poderá ser quebrada antes
                        de atingir o limite de <b>120</b> caracteres. Deverão ser adicionados 2 níveis de indentação a uma linha quebrada. Por exemplo:
                        <pre class="prettyprint pln">
if (chamadaDeMetodo1(param1, param2) && chamadaDeMetodo2() && chamadaDeMetodo3() &&
        chamadaDeMetodo4()) {
    // ...
}
</pre>
<pre class="prettyprint pln">
// Quebrando a linha antes de atingir 120 caracteres para melhorar a legibilidade.
return peticao.envolvidos().stream()
        .map(envolvidoDtoAssembler::toDto)
        .collect(Collectors.toList());
</pre>
                    </p>
                    <h5 id="formatacao-quando-quebrar" style="padding-bottom: 0px;">Quando quebrar</h5>
                    <p>
                        A seguir estão algumas diretrizes de quando quebrar a linha:
                        <ul>
                            <li>
                                Métodos e construtores devem ter o parênteses de abertura na mesma linha, mesmo que ultrapassem o limite de tamanho
                                de coluna. Apesar disso, deve-se evitar nomes de métodos grandes demais, a ponto de ultrapassar esse limite. 
                            </li>
                            <li>
                                Quando uma linha for quebrada em uma expressão de atribuição, a quebra deve ocorrer após o símbolo de igual.
                            </li>
                            <li>
                                Em blocos <i>multi-catch</i>, o operador <code>|</code> deve aparecer antes da quebra de linha.
                            </li>
                        </ul>
                    </p>
                    <h4 id="formatacao-blocos-vazios" style="padding-bottom: 0px;">Blocos vazios</h4>
                    <p>
                        <i>Opcionalmente</i> um bloco vazio pode ser fechado imediatamente depois de ser aberto, sem nenhum caracter ou quebra de linha entre as chaves,
                        a não ser que seja uma instrução de multi-bloco (uma que contém múltiplos blocos <code>if/else-if/else</code> ou
                        <code>try/catch/finally</code>)
                        Exemplo:
                        <pre class="prettyprint pln">
void metodo() {}
</pre>
                    </p>
                    <h4 id="formatacao-lambda" style="padding-bottom: 0px;"><i>Lambdas</i></h4>
                    <p>
                        Ao escrever expressões <i>lambda</i>, especialmente como parâmetros para métodos da API de <i>streams</i>, deve-se optar
                        por deixar cada chamada de método que receba uma expressão <i>lambda</i> em uma linha separada. Por exemplo:
<pre class="prettyprint pln">
return Optional.ofNullable(SecurityContextHolder.getContext().getAuthentication())
        .filter(OAuth2Authentication.class::isInstance)
        .map(OAuth2Authentication.class::cast)
        .map(auth -> auth.getUserAuthentication().getDetails())
        .map(Map.class::cast)
        .map(principal -> principal.get("componentes"))
        .map(List.class::cast)
        .map(componentes -> componentes.contains(componente.getId()))
        .orElse(false);
</pre>
                    </p>
                    <h3 id="nomeacao" style="padding-bottom: 0px;">Nomeação</h3>
                    <hr>
                    <h4 id="nomeacao-identificadores" style="padding-bottom: 0px;">Identificadores</h4>
                    <p>
                        Os identificadores devem seguir as <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">regras do Java</a>.
                        Evite utilizar identificadores com apenas um caracter. Por exemplo, prefira <code>Method metodo</code> a <code>Method m</code> (uma 
                        exceção a essa recomendação é a já tradicional utilização de <code>i</code>, <code>j</code>, <code>k</code>, etc como identificadores de contadores, especialmente
                        em instruções <code>for</code>)
                    </p>
                    <h4 id="nomeacao-constantes" style="padding-bottom: 0px;">Constantes</h4>
                    <p>
                        Nomes de constantes utilizam todas suas letras em maiúsculas com as palavras separadas por <i>underscore</i> (<code>CONSTANT_CASE</code>).
                        Toda constante é um campo com os modificadores <code>static</code> e <code>final</code>, porém nem todos os campos com esses
                        modificadores são constantes. Um campo <code>static final</code> cujo estado observável pode mudar certamente não pode
                        ser considerado uma constante. Por exemplo:
                        <pre class="prettyprint pln">
// Constantes
private static final Object NULL_HOLDER = new NullHolder();
public static final int DEFAULT_PORT = -1;

// Não são constantes
private static final ThreadLocal<Executor> executorHolder = new ThreadLocal<Executor>();
private static final Set<String> internalAnnotationAttributes = new HashSet<String>();
                        </pre>
                    </p>
                    <h4 id="nomeacao-pacotes" style="padding-bottom: 0px;">Pacotes</h4>
                    <p>
                        Nomes de pacotes devem estar com todas as letras em minúsculo, com palavras consecutivas apenas concatenadas,
                        sem <i>underscore</i> entre elas. Por exemplo, <code>br.jus.stf.plataforma.userauthentication</code>, mas não
                        <code>br.jus.stf.plataforma.userAuthentication</code> ou <code>br.jus.stf.plataforma.user_authentication</code>.
                    </p>
                    <h4 id="nomeacao-classes" style="padding-bottom: 0px;">Classes</h4>
                    <p>
                        Os nomes de classes devem ser escritos em <code>UpperCamelCase</code>. Nomes de classe são tipicamente substantivos ou
                        substantivos seguidos de qualificadores. Por exemplo, <code>Anexo</code> ou <code>ClassePeticionavel</code>.
                        Nomes de interfaces também podem ser substativos ou substantivos seguidos de qualificadores (por exemplo, <i>List</i>),
                        além de adjetivos (por exemplo, <code>Peticionavel</code>).
                    </p>
                    <p>
                        Classes de teste unitário devem iniciar com o nome da classe que estão testando seguido de <code>UnitTests</code>. Por exemplo,
                        <code>PecaUnitTests</code>. Classes de teste de integração devem iniciar com o nome da funcionalidade seguido de <code>IntegrationTests</code>.
                        Por exemplo, <code>ProcessoOriginarioIntegrationTests</code>.
                    </p>
                    <h4 id="nomeacao-metodos" style="padding-bottom: 0px;">Métodos</h4>
                    <p>
                        Nomes de métodos devem ser escritos em <code>lowerCamelCase</code>. Nomes de métodos são tipicamente verbos ou
                        verbos seguidos de qualificadores. Por exemplo, <code>handle</code> ou <code>autuarRecursal</code>. No contexto do DDD,
                        em alguns casos, podem também existir métodos escritos como substantivos. Isso ocorre especificamente quando o método
                        retorna alguma propriedade do domínio (normalmente em substituição aos <i>getters</i>).
                    </p>
                    <h4 id="nomeacao-campos" style="padding-bottom: 0px;">Campos</h4>
                    <p>
                        O nome de campos não constantes (estáticos ou não) devem ser escritos em <code>lowerCamelCase</code>. Esses nomes são normalmente
                        substantivos ou substantivos seguidos de qualificadores. Por exemplo, <code>numeroProcesso</code> ou <code>peticao</code>.
                    </p>
                    <h4 id="nomeacao-parametros" style="padding-bottom: 0px;">Parâmetros</h4>
                    <p>
                        Os nomes de parâmetros de métodos devem ser escritos em <code>lowerCamelCase</code>.
                        Nomes de parâmetros com apenas um caracter devem ser evitados em métodos públicos.
                    </p>
                    <h4 id="nomeacao-variaveis-locais" style="padding-bottom: 0px;">Variáveis locais</h4>
                    <p>
                        Os nomes de variáveis locais devem ser escritos em <code>lowerCamelCase</code>. Mesmo quando finais e imutáveis,
                        variáveis locais não são consideradas constantes e não devem ter seus nomes em <code>CONSTANT_CASE</code>.
                    </p>
                    <h4 id="nomeacao-variaveis-tipo" style="padding-bottom: 0px;">Variáveis de tipo parametrizado</h4>
                    <p>
                        Os nomes das variáveis de tipo parametrizado devem ser escritos com uma única letra maiúscula,
                        opcionalmente seguida de um único numeral (por exemplo, <code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>).
                    </p>
                    <h3 id="comentarios" style="padding-bottom: 0px;">Comentários</h3>
                    <hr>
                    <p>
                        Comentários de bloco devem aparecer no mesmo nível de indentação do código no qual eles apareçam. Eles podem ser escritos
                        no estilo <code>/* ... */</code> ou <code>// ...</code>. Para comentários de várias linhas, cada linha subsquente deve
                        começar com <code>*</code> alinhado ao <code>*</code> da linha anterior. Por exemplo:
<pre class="prettyprint pln">
/*
 * Exemplo de             // Exemplo de
 * comentário.            // comentário.
 */
</pre>
                        Se o comentário tiver apenas uma linha, deve-se utilizar preferencialmente o estilo <code>// ...</code>.
                        Por exemplo:
<pre class="prettyprint pln">
// Recupera o próximo status.
Status status = statusAdapter.nextStatus(protocolo.identity(), command.getTipoProcesso());
</pre>
                    </p>
                    <p>
                        O limite de tamanho de coluna dos comentários também é de <b>120</b> caracteres.
                    </p>
                    <h3 id="javadoc" style="padding-bottom: 0px;"><i>Javadoc</i></h3>
                    <hr>
                    <h4 id="javadoc-formatacao" style="padding-bottom: 0px;">Formatação</h4>
                    <p>
                        O <i>javadoc</i> deve ser escrito no estilo <code>/** ... */</code> e possui um limite de
                        tamanho de coluna de <b>120</b> caracteres. Por exemplo:
<pre class="prettyprint pln">
/**
 * Este é um exemplo de um Javadoc. O texto deve ser escrito e quebrará
 * normalmente.
 */
public Integer metodo(String parametro) {
    ...
}
</pre>
                        A primeira linha do <i>javadoc</i> conterá sempre apenas os caracteres <code>/**</code>. Todos os
                        parágrafos exceto o primeiro conterá <code>&lt;p&gt;</code> antes da primeira palavra (lembrando que essa
                        tag não precisa ser fechada com <code>&lt;/p&gt;</code>).
                    </p>
                    <p>
                        O primeiro parágrafo do <i>javadoc</i> deverá conter uma breve descrição da classe ou método. Os parágrafos
                        subsequentes poderão detalhar o funcionamento da classe ou método.
                    </p>
                    <h4 id="javadoc-clausulas-at" style="padding-bottom: 0px;">Cláusulas @</h4>
                    <p>
                        As cláusulas <code>@author</code> e <code>@since</code> são obrigatórias para <i>javadocs</i> de classes
                        <i>top-level</i> e devem aparecer no fim do <i>javadoc</i>, depois de seus parágrafos de descrição.
                        Normalmente não se deve utilizar <code>@author</code> em métodos específicos de uma classe. Caso
                        mais de um desenvolvedor tenha contribuído com a escrita de uma classe, mais de uma cláusula <code>@author</code>
                        deverá ser colocada no <i>javadoc</i> da classe com os respectivos autores. Já o <code>@since</code> poderá
                        ser utilizado em algum método da API pública de uma classe.
                    </p>
                    <p>
                        As outras cláusulas @ que podem aparecer em uma linha isoladas devem aparecer na seguinte ordem:
                        <code>@author, @since, @param, @return, @throws, @see, @deprecated</code>.
                    </p>
                    <p>
                        A seguir estão algumas orientações específicas de algumas cláusulas:
                        <ul>
                            <li><code>@since</code>: Poderá ter a versão da proxima release. Enquanto não tiver nenhuma release, deverá ser 1.0.0.
                            Também poderá aparecer uma cláusula <code>@since</code> com a data na qual a classe foi criada no formato dd.mm.aaaa (dia, mês, ano)</li>
                            <li><code>@param</code>: Essa cláusula deverá ser seguida por espaço e o nome do parâmetro do método. Depois do nome, deverá seguir
                            uma breve descrição do parâmetro precedida por um espaço em branco.</li>
                            <li><code>@return</code>: Essa cláusula deverá ser seguida por uma descrição do retorno do método.</li>
                            <li><code>@throws</code>: Essa cláusula deverá ser usada para documentar exceções checadas ou não-checadas que podem ser lançadas
                            pelo método. Deverá seguir o padrão <code>@throws MinhaExcecao se ...</code>, que trará a situação sob a qual essa
                            exceção será lançada.</li>
                        </ul>
                    </p>
                    <h4 id="javadoc-quando-utilizar" style="padding-bottom: 0px;">Quando utilizar</h4>
                    <p>
                        O <i>javadoc</i> deverá estar presente no mínimo para cada classe pública e para cada método público ou protegido dela, com algumas
                        exceções a seguir:
                        <ul>
                            <li>Métodos simples e óbvios como <code>getSigla</code> ou <code>setSigla</code></li>
                            <li>Métodos que sobreescrevem métodos de classes-pai.</li>
                        </ul>
                        Outras classes e métodos que não os citados acima também podem opcionalmente ter <i>javadoc</i>, quando necessário
                        para esclarecer o código.
                    </p>
                    <h3 id="praticas-programacao" style="padding-bottom: 0px;">Boas práticas de programação</h3>
                    <hr>
                    <h4 id="utilizacao-override" style="padding-bottom: 0px;">Utilização de <code>@Override</code></h4>
                    <p>
                        Um método deve ser anotado com <code>@Override</code> sempre que esse método estiver sobreescrevendo um método de uma
                        classe pai ou implementando um método de uma interface.
                    </p>
                    <h4 id="metodos-setter" style="padding-bottom: 0px;">Métodos <i>setter</i></h4>
                    <p>
                        Crie métodos <i>setters</i> apenas se eles realmente forem necessários. A ordem dos <i>setters</i> deve refletir sua importância e
                        não apenas a ordem histórica de inclusão. Além disso, essa ordem deverá ser consistente com a ordem dos campos. 
                    </p>
                    <h4 id="operador-ternario" style="padding-bottom: 0px;">Operador ternário</h4>
                    <p>
                        Sempre coloque o operador ternário entre parênteses. Por exemplo:
                        <pre class="prettyprint pln">
return (foo != null ? foo : "default");
</pre>
                    </p>
                    <h4 id="referencias-metodo-campo" style="padding-bottom: 0px;">Referências a métodos e campos</h4>
                    <p>
                        Um campo de uma classe deve sempre ser referenciado utilizando <code>this</code>. Por outro lado,
                        um método de uma classe nunca deve ser referenciado usando <code>this</code>.
                    </p>
                    <h4 id="documentacao-apis" style="padding-bottom: 0px;">Documentação de APIs</h4>
                    <p>
                        As APIs Rest deverão ser documentadas com as anotações do <i>Swagger</i>. O método da classe <code>RestResource</code>
                        responsável por tratar alguma operação deve ser anotado com <code>@ApiOperation</code> com uma descrição apropriada
                        para a operação. Por exemplo:
                        <pre class="prettyprint pln">
@RequestMapping(value = "/devolucao-assinatura", method = RequestMethod.POST)
@ApiOperation(value = "Realiza a assinatura do ofício de devolução de uma remessa")
public void assinarOficio(@RequestBody @Valid AssinarOficioParaDevolucaoCommand command,
        BindingResult binding) {
    if (binding.hasErrors()) {
        throw new IllegalArgumentException(message(binding));
    }
    
    recebimentoApplicationService.handle(command);
}
</pre>
                    Os <i>commands</i> recebidos pelas APIs Rest deverão ser documentados com as anotações <code>@ApiModel</code> no
                    nível da classe e <code>@ApiModelProperty</code> nos seus campos. Por exemplo:
                        <pre class="prettyprint pln">
@ApiModel(
        description = "Command que realiza a ação de assinatura do ofício de devolução de uma remessa")
public class AssinarOficioParaDevolucaoCommand {

    @NotNull
    @ApiModelProperty("Protocolo da remessa")
    private Long protocoloId;
</pre>
                    </p>
                    <h3 id="praticas-ddd" style="padding-bottom: 0px;">Práticas do Domain-Driven Design</h3>
                    <hr>
                    <h4 id="classes-dominio" style="padding-bottom: 0px;">Classes de domínio</h4>
                    <p>
                        A seguir estão algumas regras gerais sobre práticas recomendadas nas classes de domínio:
                        <ul>
                            <li>
                                Os nomes das classes devem refletir a <a href="http://martinfowler.com/bliki/UbiquitousLanguage.html">linguagem ubíqua</a>
                                baseada no modelo de domínio.
                            </li>
                            <li>
                                Não deverão ser usados métodos <i>getters</i> iniciando com <code>get</code>. Tais métodos deverão
                            ser nomeados com apenas o nome da propriedade de negócio que ele representa. Por exemplo:
<pre class="prettyprint pln">public PessoaId pessoa() {
    return pessoa;
}
</pre></li>
                            <li>
                                Não deverão existir métodos <i>setters</i> para simplesmente alterar um estado de um objeto de domínio. A alteração de seu
                                estado deverá ocorrer por meio de métodos com nomes que reflitam a linguagem ubíqua adotada. Por exemplo:
<pre class="prettyprint pln">
public void autuar(Classe classe, Long numero, Set<Parte> partes, Autuador autuador, Status status) {
    identificar(classe, numero);
    autuar(partes, autuador, status);
}
</pre>
                            </li>
                        </ul>
                    </p>
                    <h3 id="formatador-codigo-java" style="padding-bottom: 0px;">Formatador de código Java</h3>
                    <hr>
                    <p>
                        A seguir poderá ser baixado o formatador de código Java para o Eclipse:
                        <a href="../assets/xmls/STF Digital-Java-Formatter.xml" target="_blank">Download</a>
                    </p>

                    <h2 id="padrao-codificao-frontend" style="padding-bottom: 0px;">Padrão de Codificação de <i>Front-end</i> (Typescript)</h2>
                    <hr>
                    <ol>
                        <li>
                            <a href="#fe-arquivos-codigo-fonte">Arquivos de código-fonte</a>
                            <ol>
                                <li><a href="#fe-nome-arquivo">Nome de arquivo</a></li>
                                <li><a href="#fe-codificacao-arquivo">Codificação de arquivo</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#fe-estrutura-arquivos-codigo-fonte">Estrutura de arquivos de código-fonte</a>
                            <ol>
                                <li><a href="#fe-instrucoes-import">Instruções import</a></li>
                                <li>
                                    <a href="#fe-declaracoes-tipos">Declarações de tipos</a>
                                    <ol>
                                        <li><a href="#fe-ordem-membros-classe">Ordem dos membros de uma classe</a></li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#fe-formatacao">Formatação</a>
                            <ol>
                                <li><a href="#fe-formatacao-indentacao">Indentação</a></li>
                                <li><a href="#fe-formatacao-instrucoes">Uma instrução por linha</a></li>
                                <li><a href="#fe-formatacao-espacos-branco">Linhas em branco</a></li>
                                <li><a href="#fe-formatacao-chaves">Chaves</a></li>
                                <li>
                                    <a href="#fe-formatacao-quebra-linha">Quebras de linha</a>
                                    <ol>
                                        <li><a href="#fe-formatacao-quando-quebrar">Quando quebrar</a></li>
                                        <li><a href="#fe-formatacao-blocos-vazios">Blocos vazios</a></li>
                                        <li><a href="#fe-formatacao-funcoes-anonimas">Funções anônimas</a></li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#fe-nomeacao">Nomeação</a>
                            <ol>
                                <li><a href="#fe-nomeacao-identificadores">Identificadores</a></li>
                                <li><a href="#fe-nomeacao-variaveis">Variáveis e funções</a></li>
                                <li><a href="#fe-nomeacao-namespaces">Namespaces</a></li>
                                <li><a href="#fe-nomeacao-tipos">Classes, <i>Interfaces</i> e <i>Enums</i></a></li>
                                <li><a href="#fe-nomeacao-metodos">Métodos e Funções</a></li>
                                <li><a href="#fe-nomeacao-propriedades">Propriedades</a></li>
                                <li><a href="#fe-nomeacao-parametros">Parâmetros</a></li>
                                <li><a href="#fe-nomeacao-variaveis-locais">Variáveis locais</a></li>
                                <li><a href="#fe-nomeacao-tipos-parametrizados">Variáveis de tipos parametrizados (generics)</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#fe-comentarios">Comentários</a>
                        </li>
                        <li>
                            <a href="#fe-jsdoc">JSDoc</a>
                            <ol>
                                <li><a href="#fe-jsdoc-formatacao">Formatação</a></li>
                                <li><a href="#fe-jsdoc-clausulas-at">Cláusulas @</a></li>
                                <li><a href="#fe-jsdoc-quando-utilizar">Quando utilizar</a></li>
                            </ol>
                        </li>
                        <li>
                            <a href="#fe-construcoes-especificas">Construções específicas</a>
                            <ol>
                                <li><a href="#fe-instrucao-simples">Instrução simples</a></li>
                                <li><a href="#fe-instrucao-composta">Instrução composta</a></li>
                                <li><a href="#fe-strings">Strings</a></li>
                                <li><a href="#fe-metodos">Métodos</a></li>
                                <li><a href="#fe-if">If</a></li>
                                <li><a href="#fe-for">For</a></li>
                                <li><a href="#fe-while">While</a></li>
                                <li><a href="#fe-do-while">Do While</a></li>
                                <li><a href="#fe-switch">Switch</a></li>
                                <li><a href="#fe-try">Try</a></li>
                            </ol>
                        </li>
                    </ol>
                    <h3 id="fe-arquivos-codigo-fonte" style="padding-bottom: 0px;">Arquivos de código-fonte</h3>
                    <hr>
                    <p>
                        Funcionalidade é um nome utilizado para descrever um caso de uso da interface gráfica e agrupa um conjunto
                        de componentes <i>AngularJS</i> e tipos do Typescript.
                    </p>
                    <h4 id="fe-nome-arquivo" style="padding-bottom: 0px;">Nome de arquivo</h4>
                    <p>
                        O nome de um arquivo de código-fonte terá a extensão ".ts" e seguirá as seguintes regras de formação: 
                        <ul>
                            <li>
                                Para arquivos com componentes do <i>Angular</i> como <i>modules</i>, <i>controllers</i>, <i>services</i>,
                                <i>filters</i>, etc., o nome deverá ser formado por <code>nome-componente.tipo.ts</code>, em que <code>nome-componente</code>
                                é a parte inicial do nome da classe convertido de <code>CammelCase</code> para <code><a href="http://c2.com/cgi/wiki?KebabCase">kebab-case</a></code>
<pre class="prettyprint pln">
// Arquivo <span style="color: red;">peticionamento-originario</span>.<span style="color: blue;">controller</span>.ts
...
export class <span style="color: red;">PeticionamentoOriginario</span><span style="color: blue;">Controller</span> {
    ...
}

peticionamentoOriginario.controller("app.autuacao.peticionamento.originario.<span style="color: red;">PeticionamentoOriginario</span><span style="color: blue;">Controller</span>",
        <span style="color: red;">PeticionamentoOriginario</span><span style="color: blue;">Controller</span>);
...
</pre>
                            </li>
                            <li>
                                Tipos que são compartilhados para utilização em mais de um ponto de uma funcionalidade devem ser incluídos em um único arquivo com o nome
                                <code>funcionalidade.model.ts</code>. Tipos que são utilizados apenas na implementação de um único componente podem
                                permanecer no próprio arquivo do mesmo e não devem ser exportados.
                            </li>
                            <li>
                                Quando um componente <i>AngularJS</i> for implementado por uma classe, o nome do arquivo que o contém deve ser o nome dela (desconsiderando o
                                sufixo do tipo de componente) todo em minúsculo convertendo de <code>CammelCase</code> para a notação de cada palavra separada
                                por hífen (<code><a href="http://c2.com/cgi/wiki?KebabCase">kebab-case</a></code>), seguido de ".", do tipo do componente e da extensão ".ts".
                                Por exemplo, a classe <code>AutuacaoRecursalService</code> deve estar em um arquivo de nome <code>autuacao-recursal.service</code>,
                                a classe <code>AutuacaoRecursalController</code> em um de nome <code>autuacao-recursal.controller</code>.
                            </li>
                        </ul>
                        Exemplos:
<pre class="prettyprint pln">
// Arquivo <span style="color: red;">autuacao-recursal</span>.<span style="color: blue;">service</span>.ts
...
import autuacaoRecursal from "../shared/recursal.module";

class ValidadorAutuacao implements cmd.CommandValidator {
    ... // Essa classe pode ficar no mesmo arquivo que a classe AutuacaoRecursalService, pois é utilizada apenas aqui.
}

export class <span style="color: red;">AutuacaoRecursal</span><span style="color: blue;">Service</span> {
    ... // Classe principal do arquivo, que vai determinar o nome dele.
}

autuacaoRecursal.service("app.autuacao.recursal.<span style="color: red;">AutuacaoRecursal</span><span style="color: blue;">Service</span>", <span style="color: red;">AutuacaoRecursal</span><span style="color: blue;">Service</span>);

...
</pre>
<pre class="prettyprint pln">
// Arquivo autuacao-recursal.model.ts. "autuacao-recursal" é o nome da funcionalidade que utiliza esses tipos.
...
export class AutuarProcessoRecursalCommand implements Command {
    ...
}

export interface ProcessoRecursal extends Processo {
    ...
}
</pre>
                    </p>
                    <h4 id="fe-codificacao-arquivo" style="padding-bottom: 0px;">Codificação de arquivo</h4>
                    <p>
                        A codificação dos arquivos de código-fonte será a UTF-8.
                    </p>
                    <h3 id="fe-estrutura-arquivos-codigo-fonte" style="padding-bottom: 0px;">Estrutura de arquivos de código-fonte</h3>
                    <hr>
                    <p>
                        Um arquivo de código-fonte consiste das seguintes seções (quando existir), nessa ordem:
                        <ol>
                            <li>Bloco de <i>namespace</i></li>
                            <li>Instruções <i>import</i></li>
                            <li>Definições de tipos (classes, <i>interfaces</i> e <i>enums</i>, etc) e funções</li>
                            <li>Instruções executáveis (serão executadas quando um módulo for importado)</li>
                        </ol>
                        Exatamente uma linha em branco separará uma seção da outra. 
                    </p>
                    <h4 id="fe-instrucoes-import" style="padding-bottom: 0px;">Instruções <i>import</i></h4>
                    <p>
                         Deve-se utilizar a notação de import/export do ECMAScript 2015. Exemplos:
<pre class="prettyprint pln">
import {Parte, Processo} from "../../shared/autuacao.model";
</pre>
<pre class="prettyprint pln">
import IStateService = angular.ui.IStateService;
</pre>
<pre class="prettyprint pln">
...
autuacaoRecursal.controller("app.autuacao.recursal.AutuacaoRecursalController", AutuacaoRecursalController);

export default autuacaoRecursal;
</pre>
                        No <i>import</i>, não deverão ser utilizados espaços depois de <code>{</code> e antes de <code>}</code>.
                    </p>
                    <p>
                        Os imports deverão ser organizados em grupos na seguinte ordem, cada qual separado do outro por uma linha em branco:
                        <ul>
                            <li><i>Imports</i> de bibliotecas externas</li>
                            <li><i>Imports</i> de bibliotecas do STF Digital que estão fora do contexto atual</li>
                            <li><i>Imports</i> de bibliotecas do contexto atual (<i>imports</i> relativos)</li>
                            <li><i>Imports</i> diretos de arquivos</li>
                        </ul>
                        Nesses grupos, primeiro deverão aparecer os <i>imports</i> de <i>alias</i> e depois os <i>imports</i>
                        de módulos externos. No caso de imports de módulos externos, deverão aparecer primeiro os <i>imports</i>
                        de tipos e depois os <i>imports</i> de variáveis. Cada <i>import</i> de um módulo deve trazer todos
                        os tipos que são importados dele entre chaves e separados por vírgula e espaço. A ordem dos tipos
                        importados deve ser a ordem alfabética. No caso de várias instruções <i>imports</i> de diferentes
                        módulos, essas instruções devem ser ordenadas alfabeticamente pelo nome do módulo. Se o nome do módulo
                        for um nome relativo ao módulo atual, os módulos mais distantes do módulo atual devem aparecer primeiro.   
                    </p>
                    <p>
                        Exemplos:
<pre class="prettyprint pln">
import IHttpService = angular.IHttpService; // Alias para biblioteca externa
import IHttpPromiseCallbackArg = angular.IHttpPromiseCallbackArg;
import IPromise = angular.IPromise;

import cmd = app.support.command;
import Properties = app.support.constants.Properties;

import {AutuarProcessoRecursalCommand, Tese} from "../shared/recursal.model"; // Ordem alfabética dentro dos parênteses
// Apesar de o nome do módulo abaixo começar com "a", o módulo acima, cujo nome começa com "s",
// está mais distante relativamente do que o abaixo
import {AutuacaoRecursalService} from "./autuacao-recursal.service"; 
import autuacaoRecursal from "../shared/recursal.module";
</pre>
                    </p>
                    <h4 id="fe-declaracoes-tipos" style="padding-bottom: 0px;">Declarações de tipos</h4>
                    <p>
                         Um arquivo pode conter várias declarações de tipos. No caso de classes que são componentes <i>AngularJS</i>, é
                         recomendável que apenas essa classe seja exportada, sendo permitida a declaração de outros tipos auxiliares mas que não devem
                         ser exportados. Um tipo deverá ser definido antes de ser utilizado por outro tipo. Portanto, se a <code>ClasseA</code> utilizar
                         a <code>ClasseB</code>, a definição da <code>ClasseA</code> deverá aparecer antes da definição da <code>ClasseB</code>
                         no arquivo de código-fonte.
                    </p>
                    <h5 id="fe-ordem-membros-classe" style="padding-bottom: 0px;">Ordem dos membros de uma classe</h5>
                    <p>
                        A ordem dos membros da classe deve ser a seguinte:
                        <ul>
                            <li>Campos estáticos</li>
                            <li>Campos de instância</li>
                            <li>Construtores</li>
                            <li>Métodos privados chamados por todos os construtores</li>
                            <li>Métodos-fábrica estáticos</li>
                            <li><i>Getters</i> e <i>setters</i></li>
                            <li>Implementações de métodos oriundos de <i>interfaces</i></li>
                            <li>Métodos privados ou protegidos que são chamados por implementações de métodos oriundos de interfaces</li>
                            <li>Outros métodos</li>
                        </ul>
                        Os métodos privados devem ser colocados imediatamente abaixo do método que os referencia. 
                    </p>
                    <h3 id="fe-formatacao" style="padding-bottom: 0px;">Formatação</h3>
                    <hr>
                    <h4 id="fe-formatacao-indentacao" style="padding-bottom: 0px;">Indentação</h4>
                    <p>
                        Cada nível de indentação deve conter 4 espaços em branco. Tabs não deverão ser utilizados para esse propósito.
                    </p>
                    <h4 id="fe-formatacao-instrucoes" style="padding-bottom: 0px;">Uma instrução por linha</h4>
                    <p>
                        Cada instrução deverá ser seguida de uma quebra de linha.
                    </p>
                    <h4 id="fe-formatacao-espacos-branco" style="padding-bottom: 0px;">Linhas em branco</h4>
                    <p>
                        Uma linha em branco deverá aparecer:
                        <ul>
                            <li>
                                Entre membros consecutivos de uma classe: campos, construtores, métodos.
                            </li>
                            <li>
                                Entre instruções, conforme necessidade, para organizar o código em subseções lógicas.
                            </li>
                            <li>
                                Entre cada grupo de instruções <i>import</i>.
                            </li>
                            <li>
                                <i>Opcionalmente</i> antes do primeiro membro ou depois do último membro da classe.
                            </li>
                        </ul>
                    </p>
                    <h4 id="fe-formatacao-chaves" style="padding-bottom: 0px;">Chaves</h4>
                    <p>
                        Construções similares a bloco (corpo de classe, interface, método ou construtor) devem seguir o estilo de
                        Kernighan & Ritchie (também conhecido como chaves egípcias):
                        <ul>
                            <li>Nenhuma quebra de linha antes da chave de abertura mas um único espaço antes dela.</li>
                            <li>Quebra de linha após a chave de abertura.</li>
                            <li>Quebra de linha antes da chave de fechamento.</li>
                            <li>Quebra de linha depois da chave de fechamento caso ela termine uma instrução ou o corpo
                                de um método, construtor.
                            </li>
                            <li>Nenhuma quebra de linha depois da chave caso ela seja seguida de <i>else</i>, <i>catch</i>, <i>finally</i>
                                ou ponto e vírgula. 
                            </li>
                        </ul>
                        Exemplo:
                        <pre class="prettyprint pln">
export class MinhaClasse {

    private api: string;

    public constructor(private $http: IHttpService) {
    	this.api = "minha-api"; 
    }

    public listarAssuntos(assunto: string): IPromise&lt;Assunto[]&gt; {
        return this.$http.get(this.api + '/assuntos', {params: {'termo' : assunto}})
                .then((response : ng.IHttpPromiseCallbackArg&lt;Assunto[]&gt;) => {
                    return response.data;
                });
    }

}
</pre>
                    <h4 id="fe-formatacao-quebra-linha" style="padding-bottom: 0px;">Quebras de linha</i></h4>
                    <p>
                        O limite de tamanho de coluna é de <b>120</b> caracteres. Ao quebrar expressões grandes, coloque os símbolos separadores no fim
                        da linha ao invés de na próxima linha. Para melhorar a legibilidade em algumas situações, uma linha poderá ser quebrada antes
                        de atingir o limite de <b>120</b> caracteres. Deverá ser adicionado 2 níveis de indentação a uma linha quebrada. Por exemplo:
<pre class="prettyprint pln">
public isValid(command: PeticionarOrgaoCommand): boolean {
    if (command.poloAtivo.length > 0 && command.poloPassivo.length > 0 && command.anexos.length > 0 &&
            command.classeId && command.sigilo && command.orgaoId) {
        return true;
    }
    return false;
}
</pre>
                    </p>
                    <h5 id="fe-formatacao-quando-quebrar" style="padding-bottom: 0px;">Quando quebrar</h5>
                    <p>
                        A seguir estão algumas diretrizes de quando quebrar a linha:
                        <ul>
                            <li>
                                Métodos e construtores devem ter o parênteses de abertura na mesma linha, mesmo que ultrapassem o limite de tamanho
                                de coluna. Apesar disso, deve-se evitar nomes de métodos grandes demais, a ponto de ultrapassar esse limite.
                            </li>
                            <li>
                                Quando uma linha for quebrada em uma expressão de atribuição, a quebra deve ocorrer após o símbolo de igual.
                            </li>
                            <li>
                                Objetos escritos na notação JSON devem ser quebrados depois do <code>{</code> e antes do <code>}</code>, com
                                cada propriedade escrita em uma linha. Entretanto, depois do <code>{</code>, apenas 1 nível de indentação deve ser adicionado após
                                a quebra.
<pre class="prettyprint pln">
$stateProvider.state("app.tarefas.analise-repercussao-geral", {
    url: "/autuacao/recursal/:informationId/analise-repercussao-geral",
    views: {
        "content@app.autenticado": {
            templateUrl: "./analise-repercussao-geral.tpl.html",
            controller: "app.autuacao.recursal.AnaliseRepercussaoGeralController",
            controllerAs: "analise"
        }
    }
    ...
});
</pre>
                            </li>
                        </ul>
                    </p>
                    <h5 id="fe-formatacao-blocos-vazios" style="padding-bottom: 0px;">Blocos vazios</h5>
                    <p>
                        <i>Opcionalmente</i> um bloco vazio pode ser fechado imediatamente depois de ser aberto, sem nenhum caracter ou quebra de linha entre as chaves,
                        a não ser que seja uma instrução de multi-bloco (uma que contém múltiplos blocos <code>if/else-if/else</code>)
                        Exemplos:
                        <pre class="prettyprint pln">
class Foo {

    public metodo(parametro: string): void {}

}

export class Bar {}
</pre>
                    </p>
                    <h5 id="fe-formatacao-funcoes-anonimas" style="padding-bottom: 0px;">Funções anônimas</h5>
                    <p>
                        Funções anônimas devem ser escritas na notação de seta <code>() => { }</code> (<i>arrow function</i>)., quebrando
                        sempre depois de <code>{</code> e antes de <code>}</code>. Entretanto, apenas 1 nível de indentação deve ser adicionado
                        depois da quebra.
                    </p>
                    <p>Opcionalmente, caso a função anônima tenha apenas uma instrução com <code>return</code>, a função anônima poderá
                    ficar em apenas uma linha.</p>
                    <p>
                        Exemplo:
<pre class="prettyprint pln">
public distribuirProcesso(): void {
    this.distribuicaoComumService.enviarProcessoParaDistribuicao(this.cmdDistribuir).then(() => {
        this.$state.go("app.tarefas.minhas-tarefas");
        this.messagesService.success("Processo distribuído com sucesso.");
    }, () => {
        this.messagesService.error("Erro ao distribuir o processo.");
    });
}

public consultarAnaliseProcesso(processoId: number): IPromise<AnalisePressupostosFormais> {
    return this.$http.get(this.api + "/" + processoId + "/analise-pressupostos-formais")
            .then(response => response.data);
}
</pre>
                    </p>
                    <h3 id="fe-nomeacao" style="padding-bottom: 0px;">Nomeação</h3>
                    <hr>
                    <h4 id="fe-nomeacao-identificadores" style="padding-bottom: 0px;">Identificadores</h4>
                    <p>
                        Todos os nomes de variáveis, funções, classes, etc devem ser compostos de uma seuqência dos caracteres <code>A-Z</code>, <code>a-z</code>,
                        permitindo iniciar com <code>$</code> ou <code>_</code> quando for o caso.
                    </p>
                    <h5 id="fe-nomeacao-variaveis" style="padding-bottom: 0px;">Variáveis e funções</h5>
                    <p>
                        Nomes de variáveis e funções devem ser escritos em <code>lowerCamelCase</code>.
                    </p>
                    <h5 id="fe-nomeacao-namespaces" style="padding-bottom: 0px;"><i>Namespaces</i></h5>
                    <p>
                        Nomes de namespaces deverão ser formados por componentes separados por ponto, sendo cada componente
                        escrito com todas as letras em minúsculo e sem hífen separando diferentes palavras. Por exemplo:
<pre class="prettyprint pln">
namespace app.novoprocesso { // Nome correto de namespace

}

namespace app.novoProcesso { // Nome incorreto de namespace. Não se deve separar palavras com cammelCase

}
</pre>
                    </p>
                    <h5 id="fe-nomeacao-tipos" style="padding-bottom: 0px;">Classes, <i>Interfaces</i> e <i>Enums</i></h5>
                    <p>
                        Os nomes de classes, <i>interfaces</i> e <i>enums</i> deverão ser escritos em <code>UpperCamelCase</code>.
                    </p>
                    <h5 id="fe-nomeacao-metodos" style="padding-bottom: 0px;">Métodos e Funções</h5>
                    <p>
                        Os nomes de métodos e funções devem ser escritos em <code>lowerCamelCase</code>. No caso de métodos,
                        suas chamadas sempre deverão ter a palavra reservada <code>this</code> antes, por imposição
                        do próprio <i>Typescript.</i> Exemplos:
<pre class="prettyprint pln">
export class NovoProcessoController {

    public classe: string;

    public criarNovoProcesso(): Processo {
        return new Processo(this.classe, this.gerarNumeroProcesso());
    }

    public gerarNumeroProcesso(): number {
        ...
    }

}
</pre>
                    </p>
                    <h5 id="fe-nomeacao-propriedades" style="padding-bottom: 0px;">Propriedades</h5>
                    <p>
                        As propriedades devem ser escritas em <code>lowerCamelCase</code>. Esses nomes são normalmente substantivos ou
                        substantivos seguidos de qualificadores. Por exemplo, <code>peticaoInicial</code> ou <code>processo</code>.
                    </p>
                    <h5 id="fe-nomeacao-parametros" style="padding-bottom: 0px;">Parâmetros</h5>
                    <p>
                        Os nomes de parâmetros de métodos, funções e construtores devem ser escritos em <code>lowerCamelCase</code>. Nomes
                        de parâmetros com apenas um caracter devem ser evitados em métodos públicos.
                    </p>
                    <h5 id="fe-nomeacao-variaveis-locais" style="padding-bottom: 0px;">Variáveis locais</h5>
                    <p>
                        Os nomes de variáveis locais devem ser escritos em <code>lowerCamelCase</code>.
                    </p>
                    <h5 id="fe-nomeacao-tipos-parametrizados" style="padding-bottom: 0px;">Variáveis de tipos parametrizados (<i>generics</i>)</h5>
                    <p>
                        Os nomes das variáveis de tipo parametrizado devem ser escritos com uma única letra maiúscula, opcionalmente seguida de um
                        único numeral (por exemplo, <code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>).
                    </p>
<pre class="prettyprint pln">
export class StepsChain&lt;S&gt; {

    ...

}
</pre>
                    <h3 id="fe-comentarios" style="padding-bottom: 0px;">Comentários</h3>
                    <hr>
                    <p>
                        Comentários de bloco devem aparecer no mesmo nível de indentação do código no qual eles apareçam. Eles podem ser escritos
                        no estilo <code>/* ... */</code> ou <code>// ...</code>. Para comentários de várias linhas, cada linha subsquente deve
                        começar com <code>*</code> alinhado ao <code>*</code> da linha anterior. Por exemplo:
<pre class="prettyprint pln">
/*
 * Exemplo de             // Exemplo de
 * comentário.            // comentário.
 */
</pre>
                        Se o comentário tiver apenas uma linha, deve-se utilizar preferencialmente o estilo <code>// ...</code>.
                        Por exemplo:
<pre class="prettyprint pln">
// Realiza a devolução da remessa.
this.devolucaoService.devolver(this.cmdDevolucao);
</pre>
                    </p>
                    <p>
                        O limite de tamanho de coluna dos comentários também é de <b>120</b> caracteres.
                    </p>
                    <p>
                        Não é necessário escrever comentários para trechos de código que são autoexplicativos. Por exemplo,
                        o comentário abaixo não contribui para facilitar o entendimento do código:
<pre class="prettyprint pln">
// Seta o indice para zero.
let indice = 0;
</pre>
                    </p>
                    <h3 id="fe-jsdoc" style="padding-bottom: 0px;"><i>JSDoc</i></h3>
                    <hr>
                    Todos os tipos (classes, <i>interfaces</i>, <i>enums</i>) e métodos públicos devem ter um bloco de comentário
                    <code>/** ... */</code> (<i>JSDoc</i>) explicando seu propósito, funcionamento, descrição de parâmetros e retornos.
                    <h4 id="fe-jsdoc-formatacao" style="padding-bottom: 0px;">Formatação</h4>
                    <p>
                        O <i>JSDoc</i> deve ser escrito no estilo <code>/** ... */</code> e possui um limite de
                        tamanho de coluna de <b>120</b> caracteres. Por exemplo:
<pre class="prettyprint pln">
/**
 * Este é um exemplo de um JSDoc. O texto deve ser escrito e quebrará
 * normalmente.
 */
public metodo(parametro: string): string {
    ...
}
</pre>
                        A primeira linha do <i>JSDoc</i> conterá sempre apenas os caracteres <code>/**</code>. Cada bloco
                        de texto separado por uma linha em branco no JSDoc formará um parágrafo.
                    </p>
                    <p>
                        O primeiro parágrafo do <i>JSDoc</i> deverá conter uma breve descrição da classe ou método. Os parágrafos
                        subsequentes poderão detalhar o funcionamento da classe ou método.
                    </p>
                    <h4 id="fe-jsdoc-clausulas-at" style="padding-bottom: 0px;">Cláusulas @</h4>
                    <p>
                        As cláusulas <code>@author</code> e <code>@since</code> são obrigatórias para <i>JSDocs</i> de classes
                        exportadas e devem aparecer no fim do <i>JSDoc</i>, depois de seus parágrafos de descrição.
                        Normalmente não se deve utilizar <code>@author</code> em métodos específicos de uma classe. Caso
                        mais de um desenvolvedor tenha contribuído com a escrita de uma classe, mais de uma cláusula <code>@author</code>
                        deverá ser colocada no <i>JSDoc</i> da classe com os respectivos autores. Já o <code>@since</code> poderá
                        ser utilizado em algum método da API pública de uma classe.
                    </p>
                    <p>
                        As outras cláusulas @ que podem aparecer em uma linha isolada devem aparecer na seguinte ordem:
                        <code>@author, @since, @param, @return, @throws, @see, @deprecated</code>.
                    </p>
                    <h4 id="fe-jsdoc-quando-utilizar" style="padding-bottom: 0px;">Quando utilizar</h4>
                    <p>
                        O <i>JSDoc</i> deverá estar presente no mínimo para cada classe exportada e para cada método público ou protegido dela, com algumas
                        exceções a seguir:
                        <ul>
                            <li>Métodos simples e óbvios como <code>getNumero</code> ou <code>setNumero</code>.</li>
                            <li>Métodos que sobreescrevem métodos de classes-pai.</li>
                        </ul>
                        Outras classes e métodos que não os citados acima também podem opcionalmente ter <i>JSDoc</i>, quando necessário
                        para esclarecer o código.
                    </p>
                    <h3 id="fe-construcoes-especificas" style="padding-bottom: 0px;">Construções específicas</h3>
                    <hr>
                    <h4 id="fe-instrucao-simples" style="padding-bottom: 0px;">Instrução simples</h4>
                    <p>
                        <ul>
                            <li>Cada linha deve contar no máximo uma instrução.</li>
                            <li>Ponto e vírgula deverá ser sempre colocado no fim de uma instrução.</li>
<pre class="prettyprint pln">
// Ruim. Sem ponto e vírgula.
let nomeSistema = "STF Digital"

// Bom. Com ponto e vírgula.
let nomeSistema = "STF Digital";
</pre>
                        </ul>
                    </p>
                    <h4 id="fe-instrucao-composta" style="padding-bottom: 0px;">Instrução composta</h4>
                    <p>
                        Instruções compostas são instruções contendo uma lista de instruções entre chaves (também conhecido como bloco
                        de instruções).
                        <ul>
                            <li>As instruções devem iniciar cada uma em uma linha separada.</li>
                            <li>As instruções devem ser indentadas por um nível (4 espaços).
<pre class="prettyprint pln">
// Ruim
if (condicao === true) { ... }

// Bom
if (condicao === true) {
    ...
}
</pre>
                            </li>
                            <li>As chaves devem seguir o estilo K&R, ou seja, <code>{</code> deve estar na mesma linha que inicia
                                a instrução composta e <code>}</code> deve estar sozinha em uma linha indentada de forma a estar alinhada
                                com <code>{</code>. Apesar de no estilo K&R original, o <code>{</code> de uma função ficar em uma
                                linha separada, o mesmo não se aplica à variante adotada aqui.
<pre class="prettyprint pln">
// Ruim
if (condicao === true)
{
    ...
}

// Bom
if (condicao === true) {
    ...
}

// Ruim
while (condicao)
{
    ...
}

// Bom
while (condicao) {
    ...
}
</pre>
                            </li>
                            <li>
                                Chaves <code>{}</code> devem ser utilizadas para todos os blocos de instruções compostas, mesmo que eles tenham
                                apenas uma instrução. Isso ajuda a evitar a introdução de bugs como alguém incluir mais uma instrução sem adicionar
                                as chaves. 
<pre class="prettyprint pln">
// Ruim
if (condicao === true) fazerAlgo();

// Ruim
if (condicao === true)
    fazerAlgo();

// Bom
if (condicao === true) {
    fazerAlgo();
}
</pre>
                                Entretanto, uma exceção a essa regra são as
                                <a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#4.11" target="_blank">funções flecha</a>
                                com apenas uma instrução, que podem ser escritas sem chaves <code>{}</code>. Escrevê-las dessa forma
                                permite encadear vários callbacks que transformam um objeto sequencialmente de forma concisa.
<pre class="prettyprint pln">
sc.chain(() => this.requestUserCertificate())
        .chain((certificate: Certificate) => this.storeCertificate(certificate))
        .promise();
</pre>
                            </li>
                        </ul>
                    </p>
                    <h4 id="fe-strings" style="padding-bottom: 0px;">Strings</h4>
                    <p>
                        <ul>
                            <li>
                                Utilize aspas duplas <code>""</code> para strings, inclusive para strings em instruções <code>import</code>.
<pre class="prettyprint pln">
// Ruim
let nomeSistema = 'STF Digital';

// Bom
let nomeSistema = "STF Digital";

// Ruim
import {Remessa} from '../../services/model';
import {RemessasDashletService} from '../remessas-dashlet.service';

// Bom
import {Remessa} from "../../services/model";
import {RemessasDashletService} from "../remessas-dashlet.service";
</pre>
                            </li>
                        </ul>
                    </p>
                    <h4 id="fe-metodos" style="padding-bottom: 0px;">Métodos</h4>
                    <p>
                        <ul>
                            <li>
                                Métodos devem ter seus modificadores de acesso explicitamente especificados (<code>private</code>, <code>public</code> ou
                                <code>protected</code>), devendo-se evitar deixar um método sem nenhum modificador de acesso (o que o torna <code>public</code>
                                no <i>Typescript</i>).
<pre class="prettyprint pln">
// Ruim
export class MinhaClasse {

    // Ruim
    metodoPublico1(parametro: string): void {
        ...
    }

    // Bom
    public metodoPublico2(parametro: string): void {
        ...
    }

    // Bom
    private metodoPrivado(parametro: string): number {
        ...
    }

    protected metodoProtegido(parametro: string): number {
        ...
    }

}
</pre>
                            </li>
                            <li>
                                Métodos devem definir explicitamente o tipo de retorno. Isso permite ao compilador <i>Typescript</i>
                                validar se seu método realmente está retornando o tipo especificado.
<pre class="prettyprint pln">
// Ruim
public metodo(parametro: string) {
    ...
    return 7;
}

// Bom
public metodo(parametro: string): number {
    ...
    return 7;
}
</pre>
                            </li>
                        </ul>
                    </p>
                    <h4 id="fe-if" style="padding-bottom: 0px;">If</h4>
                    <p>
                        Os ifs devem seguir a formatação do estilo K&R, como nos exemplos a seguir:
<pre class="prettyprint pln">
if (/* condicao */) {
    ...
}

if (/* condicao */) {
    ...
} else {
    ...
}

if (/* condicao */) {
    ...
} else if (/* condicao */) {
    ...
} else {
    ...
}
</pre>
                    </p>
                    <h4 id="fe-for" style="padding-bottom: 0px;">For</h4>
                    <p>
                        As instruções for devem seguir a formatação do estilo K&R, como nos exemplos a seguir:
<pre class="prettyprint pln">
for (/* inicialização */; /* condicao */; /* atualizacao */) {
    ...
}

for (let variavel in objeto) {
    ...
}

for (let variavel of objeto) {
    ...
}
</pre>
                    </p>
                    <h4 id="fe-while" style="padding-bottom: 0px;">While</h4>
                    <p>
                        As instruções while devem seguir a formatação do estilo K&R, como no exemplo a seguir:
<pre class="prettyprint pln">
while (/* condicao */) {
    ...
}
</pre>
                    </p>
                    <h4 id="fe-do-while" style="padding-bottom: 0px;">Do While</h4>
                    <p>
                        As instruções do while devem seguir a formatação do estilo K&R, terminando com <code>;</code>, como no exemplo a seguir:
<pre class="prettyprint pln">
do {
    ...
} while (/* condicao */);
</pre>
                    </p>
                    <h4 id="fe-switch" style="padding-bottom: 0px;">Switch</h4>
                    <p>
                        As instruções switch devem seguir a formatação indicada a seguir, com cada grupo case exceto o default
                        terminando com break, return ou throw.      
<pre class="prettyprint pln">
switch (/* expressao */) {
    case /* expressao1 */:
        ...
        /* terminacao1 */
    case /* expressao2 */:
        ...
        /* terminacao2 */
    default:
        ...
}
</pre>
                    </p>
                    <h4 id="fe-try" style="padding-bottom: 0px;">Try</h4>
                    <p>
                        Instruções try devem ser evitadas sempre que possível. Elas não são boas para controle de fluxo da aplicação.
                        Quando utilizadas, elas devem ser formatadas como no exemplo a seguir:
<pre class="prettyprint pln">
try {
    ...
} catch (error: Error) {
    ...
}

try {
    ...
} catch (error: Error) {
    ...
} finally {
    ...
}
</pre>
                    </p>
                    <h2 id="metricas-qualidade" style="padding-bottom: 0px;">Métricas de qualidade</h2>
                    <hr>
                    <p>
                        O desenvolvimento de <i>software</i> é realizado por equipes heterogêneas, com desenvolvedores com
                        diferentes níveis de experiência e com diferentes estilos de programação. Desse modo, caso não haja um
                        controle mínimo sobre a qualidade do <i>software</i>, ele pode crescer de forma descontrolada e se tornar
                        de difícil manutenção ou muito propenso ao aparecimento de <i>bugs</i> e vulnerabilidades.
                    </p>
                    <p>
                        As métricas de qualidade são um importante mecanismo para ajudar o acompanhamento do nível de qualidade de
                        um <i>software</i> durante o seu desenvolvimento. Elas trazem visibilidade para os gestores e para os próprios
                        desenvolvedores sobre vários aspectos do <i>software</i>, como: facilidade de manutenção, vulnerabilidades
                        de segurança, propensão ao aparecimento de <i>bugs</i> em produção, quantidade de código testado, etc.
                    </p>
                    <p>
                        Muitas dessas métricas são complexas e exigem uma análise detalhada do código-fonte do <i>software</i>, o que
                        torna inviável seu cálculo manual. Por isso, torna-se essencial a utilização de uma ferramenta específica
                        que viabilize seu cálculo automático e permita a divulgação delas de forma simples e centralizada. Atualmente
                        há várias ferramentas que podem ser utilizdas para esse propósito, dentre elas: SonarQube, Code Climate, Codacy,
                        e outras. Cada uma dessas ferramentas possui formas diferentes de exibir métricas que indiquem a qualidade do
                        código.
                    </p>
                    <p>
                        De modo geral, as sguintes métricas se aplicam a todas essas ferramentas:
                        <ul>
                            <li>Taxa de cobertura de código (Teste)</li>
                            <li>Taxa de sucesso em testes unitários</li>
                            <li>Taxa de documentação de APIs públicas</li>
                            <li>Complexidade do código</li>
                        </ul>
                    </p>
                    <h3 id="metricas-qualidade-sonarqube" style="padding-bottom: 0px;">Sonarqube</h3>
                    <hr>
                    <p>
                        No SonarQube, há algumas outras métricas facilmente disponíveis em sua interface:
                        <ul>
                            <li>Nível de manutenibilidade</li>
                            <li>Taxa de duplicação de código</li>
                            <li>
                                Violações categorizadas em diversos níveis: <i>blocker</i>, <i>critical</i>, <i>major</i>, <i>minor</i> e <i>info</i>.
                                Tais violações agregam problemas de diversas naturezas que influenciam nas outras métricas.
                            </li>
                        </ul>
                    </p>
                    <h3 id="metricas-qualidade-code-climate" style="padding-bottom: 0px;">Code Climate</h3>
                    <hr>
                    <p>
                        O Code Climate consolida pendências de qualidade em um indicar único chamado GPA, que vai de 0.0 até 4.0,
                        compreendendo as notas de <b>A</b> a <b>F</b>. Esse indicador agrega diferentes tipos de problemas no
                        código. De modo geral, deve-se buscar manter o GPA no nível A.
                    </p>
                    <h3 id="metricas-qualidade-codacy" style="padding-bottom: 0px;">Codacy</h3>
                    <hr>
                    <p>
                        No Codacy, além das métricas já mencionadas acima, também estão disponíveis as seguintes métricas:
                        <ul>
                            <li>Taxa de compatibilidade (Compatibility)</li>
                            <li>Taxa de aderência ao padrão de codificação (Code Style)</li>
                            <li>Taxa de tendência de aparecimento de erros (Error Prone)</li>
                            <li>Taxa de conformidade com boas práticas de desempenho (Performance)</li>
                            <li>Taxa de conformidade com boas práticas de segurança (Security)</li>
                            <li>Taxa de código não utilizado (Unused Code)</li>
                        </ul>
                    </p>
                    <h3 id="metricas-qualidade-metas" style="padding-bottom: 0px;">Metas</h3>
                    <hr>
                    <p>
                        As metas de nível de métricas de qualidade vão depender da ferramenta utilizada para analisar o código-fonte,
                        pois cada ferramenta tem uma forma diferente de gerar essas métricas. De modo geral, os valores das 
                        metas desses indicadores deverão ser calibrados de acordo com cada caso. Normalmente a própria ferramenta
                        mostra de forma visual que uma métrica está ruim. Deve-se procurar "zerar" todas as pendências indicadas
                        pela ferramenta ou marcar como falso positivo, caso não se aplique ao caso.  
                    </p>
                    <p>
                        A seguir temos tabelas de metas de métricas a serem perseguidas pelo STF Digital:
                    </p>
                    <table>
                        <caption>Sonarqube</caption>
                        <tr>
                            <th>Métrica</th>
                            <th>Meta</th>
                        </tr>
                        <tr>
                            <td>Taxa de cobertura de código (Teste)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de sucesso em testes unitários</td>
                            <td>=100%</td>
                        </tr>
                        <tr>
                            <td>Taxa de documentação de APIs públicas</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Complexidade do código por função/arquivo/classe</td>
                            <td><=5.0/<=5.0/<=5.0</td>
                        </tr>
                        <tr>
                            <td>Nível de manutenibilidade</td>
                            <td>=A</td>
                        </tr>
                        <tr>
                            <td>Taxa de duplicação de código</td>
                            <td><=10%</td>
                        </tr>
                        <tr>
                            <td>Violações <i>blocker</i>/<i>critical</i>/<i>major</i>/<i>minor</i>/<i>info</i></td>
                            <td>=0/=0/<=100/<=200/<=50</td>
                        </tr>
                    </table>
                    <table>
                        <caption>Code Climate</caption>
                        <tr>
                            <th>Métrica</th>
                            <th>Meta</th>
                        </tr>
                        <tr>
                            <td>Taxa de cobertura de código (Teste)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>GPA</td>
                            <td>=A</td>
                        </tr>
                    </table>
                    <table>
                        <caption>Codacy</caption>
                        <tr>
                            <th>Métrica</th>
                            <th>Meta</th>
                        </tr>
                        <tr>
                            <td>Taxa de cobertura de código (Teste)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de sucesso em testes unitários</td>
                            <td>=100%</td>
                        </tr>
                        <tr>
                            <td>Taxa de documentação de APIs públicas</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de aderência à complexidade de código aceitável</td>
                            <td>>=90%</td>
                        </tr>
                        <tr>
                            <td>Taxa de compatibilidade (Compatibility)</td>
                            <td>=100%</td>
                        </tr>
                        <tr>
                            <td>Taxa de aderência ao padrão de codificação (Code Style)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de tendência de aparecimento de erros (Error Prone)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de conformidade com boas práticas de desempenho (Performance)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de conformidade com boas práticas de segurança (Security)</td>
                            <td>>=80%</td>
                        </tr>
                        <tr>
                            <td>Taxa de código não utilizado (Unused Code)</td>
                            <td>>=80%</td>
                        </tr>
                    </table>
                </div>
    
            </div>
            <!-- end jd-content -->
        </div>
        <!--/#body-content-->
    </body>
</html>